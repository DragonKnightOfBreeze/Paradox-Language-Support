{
  parserImports="static com.intellij.lang.WhitespacesBinders.*"
  parserClass="icu.windea.pls.cwt.parser.CwtParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Cwt"
  psiImplClassSuffix="Impl"
  psiPackage="icu.windea.pls.cwt.psi"
  psiImplPackage="icu.windea.pls.cwt.psi.impl"
  elementTypeHolderClass="icu.windea.pls.cwt.psi.CwtElementTypes"
  tokenTypeFactory="icu.windea.pls.cwt.psi.CwtElementTypeFactory.getTokenType"
  elementTypeFactory="icu.windea.pls.cwt.psi.CwtElementTypeFactory.getElementType"
  psiImplUtilClass="icu.windea.pls.cwt.psi.impl.CwtPsiImplUtil"
  parserUtilClass="icu.windea.pls.cwt.parser.CwtParserUtil"
  methods(".*")=[getResolveScope getUseScope getPresentation toString]
}

// Grammar for CWT.
// Notes:
// - Supports properties, blocks, and special option/doc comments with lazy parsing.

// core rules

root ::= root_block ?
root_block ::= root_block_item + {
  hooks=[wsBinders="GREEDY_LEFT_BINDER, GREEDY_RIGHT_BINDER"]
  implements=[
    "icu.windea.pls.cwt.psi.CwtBlockElement"
  ]
  methods=[getValue getMemberList getComponents]
}
private root_block_item ::= general_comment | property | value

private general_comment ::= doc_comment | option_comment | comment
doc_comment ::= DOC_COMMENT_TOKEN {
  implements=["com.intellij.psi.PsiDocCommentBase"]
  methods=[getTokenType getOwner]
}
option_comment ::= option_comment_root {
  recoverWhile="#auto" // continue parsing
  implements=["com.intellij.psi.PsiComment"]
  methods=[getTokenType optionList="option" optionValueList="value"]
}
private comment ::= COMMENT

property ::= property_key property_separator property_value {
  pin=1
  recoverWhile="#auto" // continue parsing
  implements=[
    "icu.windea.pls.cwt.psi.CwtNamedElement"
    "icu.windea.pls.cwt.psi.CwtMember"
  ]
  methods=[
    propertyKey="property_key" propertyValue="value"
    getIcon getName setName getNameIdentifier getValue getSeparatorType
  ]
}
property_key ::= PROPERTY_KEY_TOKEN {
  implements=[
    "icu.windea.pls.cwt.psi.CwtStringExpressionElement"
    "icu.windea.pls.cwt.psi.CwtLiteralValue"
  ]
  methods=[getIcon getName getValue setValue getReference getReferences]
}
private property_separator ::= EQUAL_SIGN | NOT_EQUAL_SIGN
private property_value ::= value

value ::= boolean | int | float | string | block {
  implements=[
    "icu.windea.pls.cwt.psi.CwtExpressionElement"
    "icu.windea.pls.cwt.psi.CwtMember"
    "icu.windea.pls.cwt.psi.CwtOptionMember"
  ]
  methods=[getIcon getName getValue setValue]
}
boolean ::= BOOLEAN_TOKEN {
  extends=value
  implements=[
    "icu.windea.pls.cwt.psi.CwtLiteralValue"
  ]
}
int ::= INT_TOKEN {
  extends=value
  implements=[
    "icu.windea.pls.cwt.psi.CwtLiteralValue"
  ]
}
float ::= FLOAT_TOKEN {
  extends=value
  implements=[
    "icu.windea.pls.cwt.psi.CwtLiteralValue"
  ]
}
string ::= STRING_TOKEN {
  extends=value
  implements=[
    "icu.windea.pls.cwt.psi.CwtNamedElement"
    "icu.windea.pls.cwt.psi.CwtStringExpressionElement"
    "icu.windea.pls.cwt.psi.CwtLiteralValue"
  ]
  methods=[getIcon getName setName getNameIdentifier getValue setValue getReference getReferences]
}
block ::= LEFT_BRACE block_item * RIGHT_BRACE {
  pin=1
  extends=value
  implements=[
    "icu.windea.pls.cwt.psi.CwtNamedElement"
    "icu.windea.pls.cwt.psi.CwtBlockElement"
  ]
  methods=[getIcon getName setName getValue setValue getMemberList getComponents]
}
private block_item ::= general_comment | property | option | value {
  recoverWhile="#auto" // continue parsing
}

// option comment rules
// 2.0.7 DO NOT use lazy-parsing due to performance reasons

private option_comment_root ::= OPTION_COMMENT_START option_comment_item * {
  pin=1
  recoverWhile="#auto" // continue parsing
}
private option_comment_item ::= option | option_value {
  recoverWhile="#auto" // continue parsing
}

option ::= option_key option_separator option_value {
  pin=1
  recoverWhile="#auto" // continue parsing
  implements=[
    "icu.windea.pls.cwt.psi.CwtNamedElement"
    "icu.windea.pls.cwt.psi.CwtOptionMember"
  ]
  methods=[
    option_key="option_key" option_value="value"
    getIcon getName setName getNameIdentifier getValue getSeparatorType
  ]
}
option_key ::= OPTION_KEY_TOKEN {
  methods=[getIcon getName getValue]
}
private option_separator ::= EQUAL_SIGN | NOT_EQUAL_SIGN
private option_value ::= value
