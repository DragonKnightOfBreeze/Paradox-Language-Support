{
  parserImports="static com.intellij.lang.WhitespacesBinders.*"
  parserClass="icu.windea.pls.csv.parser.ParadoxCsvParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="ParadoxCsv"
  psiImplClassSuffix="Impl"
  psiPackage="icu.windea.pls.csv.psi"
  psiImplPackage="icu.windea.pls.csv.psi.impl"
  elementTypeHolderClass="icu.windea.pls.csv.psi.ParadoxCsvElementTypes"
  elementTypeFactory="icu.windea.pls.csv.psi.ParadoxCsvElementTypeFactory.getElementType"
  tokenTypeFactory="icu.windea.pls.csv.psi.ParadoxCsvElementTypeFactory.getTokenType"
  psiImplUtilClass="icu.windea.pls.csv.psi.impl.ParadoxCsvPsiImplUtil"
  parserUtilClass="icu.windea.pls.csv.parser.ParadoxCsvParserUtil"
  tokens=[
    SEPARATOR=";"
    EOL="<eol>"
  ]
  methods(".*")=[getResolveScope getUseScope getPresentation toString]
}

// Grammar for Paradox CSV.
// Notes:
// - Header and row share the same item structure; EOL is recognized by lexer token.
// - Empty first/middle columns are allowed; quoted columns can be unterminated for recovery.

root ::= COMMENT * header ? (row | COMMENT) *

header ::= column_items {
  implements=[
    "icu.windea.pls.csv.psi.ParadoxCsvRowElement"
  ]
  methods=[getIcon]
}
// EOL is recognized by a dedicated lexer token
row ::= column_items {
  implements=[
    "icu.windea.pls.csv.psi.ParadoxCsvRowElement"
  ]
  methods=[getIcon getComponents]
}
private column_items ::= column column_item * {
  pin=1
}
private column_item ::= <<checkEol>> SEPARATOR [<<checkEol>> column]
// Empty first/middle columns are allowed
column ::= <<checkColumnToken>> COLUMN_TOKEN ? {
  implements=[
    "icu.windea.pls.csv.psi.ParadoxCsvExpressionElement"
    "icu.windea.pls.csv.psi.ParadoxCsvLiteralValue"
  ]
  methods=[getIcon getName getValue setValue getReference getReferences]
}
