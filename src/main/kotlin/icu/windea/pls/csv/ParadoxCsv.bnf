{
  parserImports="static com.intellij.lang.WhitespacesBinders.*"
  parserClass="icu.windea.pls.csv.parser.ParadoxCsvParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="ParadoxCsv"
  psiImplClassSuffix="Impl"
  psiPackage="icu.windea.pls.csv.psi"
  psiImplPackage="icu.windea.pls.csv.psi.impl"
  elementTypeHolderClass="icu.windea.pls.csv.psi.ParadoxCsvElementTypes"
  elementTypeFactory="icu.windea.pls.csv.psi.ParadoxCsvElementTypeFactory.getElementType"
  tokenTypeFactory="icu.windea.pls.csv.psi.ParadoxCsvElementTypeFactory.getTokenType"
  psiImplUtilClass="icu.windea.pls.csv.psi.impl.ParadoxCsvPsiImplUtil"
  parserUtilClass="icu.windea.pls.csv.parser.ParadoxCsvParserUtil"
  tokens=[
    SEPARATOR=";"
    EOL="<eol>"
  ]
  methods(".*")=[getPresentation getResolveScope getUseScope]
}

root ::= COMMENT * header ? (row | COMMENT) *

header ::= column_items {
  implements=[
    "icu.windea.pls.csv.psi.ParadoxCsvRowElement"
  ]
  methods=[getIcon toString]
}
// Note that there are special codes to detect eol
row ::= column_items {
  implements=[
    "icu.windea.pls.csv.psi.ParadoxCsvRowElement"
  ]
  methods=[getIcon toString]
}
private column_items ::= column column_item * {
  pin=1
}
private column_item ::= <<checkEol>> SEPARATOR [<<checkEol>> column]
// Note that empty first/middle columns are allowed
column ::= <<checkColumnToken>> COLUMN_TOKEN ? {
  implements=[
    "icu.windea.pls.csv.psi.ParadoxCsvExpressionElement"
    "icu.windea.pls.csv.psi.ParadoxCsvLiteralValue"
  ]
  methods=[getIcon getName getValue setValue getReference getReferences toString]
}
