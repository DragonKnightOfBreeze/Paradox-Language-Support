{
	parserClass="icu.windea.pls.script.psi.ParadoxScriptParser"
	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
	psiClassPrefix="ParadoxScript"
	psiImplClassSuffix="Impl"
	psiPackage="icu.windea.pls.script.psi"
	psiImplPackage="icu.windea.pls.script.psi.impl"
	elementTypeHolderClass="icu.windea.pls.script.psi.ParadoxScriptElementTypes"
	elementTypeClass="icu.windea.pls.script.psi.ParadoxScriptElementType"
	tokenTypeClass="icu.windea.pls.script.psi.ParadoxScriptTokenType"
    elementTypeFactory="icu.windea.pls.script.psi.ParadoxScriptElementTypeFactory.getElementType"
	tokenTypeFactory="icu.windea.pls.script.psi.ParadoxScriptElementTypeFactory.getTokenType"
	psiImplUtilClass="icu.windea.pls.script.psi.impl.ParadoxScriptPsiImplUtil"
}

//忽略空白，在ParserDefinition里面定义PsiElement之间的空白类型
//regex必须定向到token，而非rule
//即使idea提示不需要转义，一些字符在regexp中仍然需要转义

//DONE 列表的元素可以是字符串
//DONE 分隔符可以是比较运算符

//root_block也是block，但不能直接extends，否则root下面会是value而非root_block
root ::= root_block
root_block ::= root_block_item * {
  extends=block
}
private root_block_item ::=  END_OF_LINE_COMMENT | COMMENT | variable | property | value

variable ::= variable_name variable_separator variable_value {
  pin=1
  recoverWhile=variable_recover
  extends="icu.windea.pls.script.psi.impl.ParadoxScriptStubElementImpl<?>"
  implements=[
    "icu.windea.pls.script.psi.ParadoxScriptNamedElement"
    "icu.windea.pls.script.psi.ParadoxScriptExpression"
  ]
  stubClass="icu.windea.pls.script.psi.ParadoxScriptVariableStub"
  methods=[getIcon getName setName getNameIdentifier getValue getUnquotedValue getValueType]
}

variable_name ::= VARIABLE_NAME_ID{
  methods=[getName setName]
}
private variable_separator ::= EQUAL_SIGN
variable_value ::= boolean | number | string
private variable_recover ::= !(BOOLEAN_TOKEN | INLINE_MATH_START | COLOR_TOKEN | COMMENT | END_OF_LINE_COMMENT | FLOAT_TOKEN | INT_TOKEN | LEFT_BRACE | PROPERTY_KEY_ID | QUOTED_PROPERTY_KEY_ID | QUOTED_STRING_TOKEN | RIGHT_BRACE | STRING_LIKE_TOKEN | STRING_TOKEN | TAG_TOKEN | VARIABLE_NAME_ID | VARIABLE_REFERENCE_ID)

property ::= property_key property_separator property_value {
  pin=1
  recoverWhile=property_recover
  extends="icu.windea.pls.script.psi.impl.ParadoxScriptStubElementImpl<?>"
  implements=[
    "icu.windea.pls.script.psi.ParadoxScriptNamedElement"
    "icu.windea.pls.script.psi.ParadoxScriptExpression"
    "icu.windea.pls.script.psi.ParadoxDefinitionProperty"
  ]
  stubClass="icu.windea.pls.script.psi.ParadoxScriptPropertyStub"
  methods=[getIcon getName setName getNameIdentifier getValue getDepth getBlock getValueType getType getPathName getOriginalPathName]
}
property_key ::= PROPERTY_KEY_ID | QUOTED_PROPERTY_KEY_ID{
  methods=[getValue setValue getReference]
}
private property_separator ::= EQUAL_SIGN | LT_SIGN | GT_SIGN | LE_SIGN | GE_SIGN | NOT_EQUAL_SIGN
property_value ::= value
//当前属性解析失败时，需要跳过继续解析下一个
private property_recover ::= !(BOOLEAN_TOKEN | COLOR_TOKEN | COMMENT | END_OF_LINE_COMMENT | FLOAT_TOKEN
  | INLINE_MATH_START | INT_TOKEN | LEFT_BRACE | PROPERTY_KEY_ID | QUOTED_PROPERTY_KEY_ID | QUOTED_STRING_TOKEN
  | RIGHT_BRACE | STRING_LIKE_TOKEN | STRING_TOKEN | TAG_TOKEN | VARIABLE_NAME_ID | VARIABLE_REFERENCE_ID)

value ::= variable_reference | boolean | number | string | color | block | inline_math {
  implements="icu.windea.pls.script.psi.ParadoxScriptExpression"
  methods=[getIcon getValue]
}
variable_reference ::= VARIABLE_REFERENCE_ID {
  extends=value
  methods=[getName setName getReference getReferenceValue getValueType]
}
boolean ::= BOOLEAN_TOKEN {
  extends=value
  implements="com.intellij.psi.PsiLiteralValue"
  methods=[getBooleanValue getValueType getType]
}
number ::= int | float {
  extends=value
  implements="com.intellij.psi.PsiLiteralValue"
  methods=[getValueType getType]
}
int ::= INT_TOKEN {
  extends=number
  methods=[getIntValue getValueType getType]
}
float ::= FLOAT_TOKEN{
  extends=number
  methods=[getFloatValue getValueType getType]
}
string ::= STRING_TOKEN | QUOTED_STRING_TOKEN {
  extends=value
  implements="com.intellij.psi.PsiLiteralValue"
  methods=[getValue setValue getReference getStringValue getValueType getType]
}
color ::= COLOR_TOKEN {
  extends=value
  implements="com.intellij.psi.PsiLiteralValue"
  methods=[getValue getColor setColor getValueType getType]
}
block ::= LEFT_BRACE block_item * RIGHT_BRACE {
  pin=1
  recoverWhile=block_recover
  extends=value
  implements="com.intellij.psi.PsiListLikeElement"
  methods=[getValue isEmpty isNotEmpty isObject isArray getComponents getValueType getType]
}
private block_item ::= END_OF_LINE_COMMENT | COMMENT | tag | variable | property | value | STRING_LIKE_TOKEN
private block_recover ::= !(BOOLEAN_TOKEN | COLOR_TOKEN | COMMENT | END_OF_LINE_COMMENT | FLOAT_TOKEN
  | INLINE_MATH_START | INT_TOKEN | LEFT_BRACE | PROPERTY_KEY_ID | QUOTED_PROPERTY_KEY_ID | QUOTED_STRING_TOKEN
  | RIGHT_BRACE | STRING_LIKE_TOKEN | STRING_TOKEN | TAG_TOKEN | VARIABLE_NAME_ID | VARIABLE_REFERENCE_ID)

//advanced script syntax
//see: common/scripted_effects/99_advanced_documentation.txt
//see wiki: https://stellaris.paradoxwikis.com/Dynamic_modding

//tag
//resolved as string, and should:
//in specific definition declarations (scripted_effect / scripted_trigger)
//in block, before any scripted variables, (non-tag) strings and properties
tag ::= TAG_TOKEN {
  methods=[getName setName]
}

//parameter condition expression

//inline math
//in specific definition declarations (scripted_effect / scripted_trigger)
//only first inline math expression in a scripted effect / trigger is correctly recognized and evaluated
inline_math ::= INLINE_MATH_START inline_math_expression INLINE_MATH_END{
  pin=1
  recoverWhile=inline_math_recover
  extends=value
  methods=[getValueType getType]
}
private inline_math_expression ::= inline_math_factor (inline_math_op inline_math_factor) *
private inline_math_op ::= PLUS_SIGN | MINUS_SIGN | TIMES_SIGN | DIV_SIGN | MOD_SIGN //+ - * / %
private inline_math_recover ::= !(BOOLEAN_TOKEN | COLOR_TOKEN | COMMENT | END_OF_LINE_COMMENT | FLOAT_TOKEN
  | INLINE_MATH_START | INT_TOKEN | LEFT_BRACE | PROPERTY_KEY_ID | QUOTED_PROPERTY_KEY_ID | QUOTED_STRING_TOKEN
  | RIGHT_BRACE | STRING_LIKE_TOKEN | STRING_TOKEN | TAG_TOKEN | VARIABLE_NAME_ID | VARIABLE_REFERENCE_ID)
inline_math_factor ::= inline_math_number | inline_math_variable_reference | inline_math_parameter
inline_math_number ::= NUMBER_TOKEN { //int / float
  implements=[
    "com.intellij.psi.PsiLiteralValue"
    "icu.windea.pls.script.psi.ParadoxScriptExpression"
  ]
  methods=[getValueType getType]
}
inline_math_variable_reference ::= INLINE_MATH_VARIABLE_REFERENCE_ID { //without prefix "@"
  implements="icu.windea.pls.script.psi.ParadoxScriptExpression"
  methods=[getIcon getName setName getReference getReferenceValue getValueType]
}
inline_math_parameter ::= DOLLAR_SIGN PARAMETER_ID [ PIPE NUMBER_TOKEN] DOLLAR_SIGN {
  pin=1
  extends="icu.windea.pls.script.psi.ParadoxScriptParameter"
}

