{
	parserClass="icu.windea.pls.script.psi.ParadoxScriptParser"
	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
	psiClassPrefix="ParadoxScript"
	psiImplClassSuffix="Impl"
	psiPackage="icu.windea.pls.script.psi"
	psiImplPackage="icu.windea.pls.script.psi.impl"
	elementTypeHolderClass="icu.windea.pls.script.psi.ParadoxScriptElementTypes"
	elementTypeClass="icu.windea.pls.script.psi.ParadoxScriptElementType"
	tokenTypeClass="icu.windea.pls.script.psi.ParadoxScriptTokenType"
    elementTypeFactory="icu.windea.pls.script.psi.ParadoxScriptElementTypeFactory.getElementType"
	tokenTypeFactory="icu.windea.pls.script.psi.ParadoxScriptElementTypeFactory.getTokenType"
	psiImplUtilClass="icu.windea.pls.script.psi.impl.ParadoxScriptPsiImplUtil"
}

//忽略空白，在ParserDefinition里面定义PsiElement之间的空白类型
//regex必须定向到token，而非rule
//即使idea提示不需要转义，一些字符在regexp中仍然需要转义

//TODO 区分不同游戏类型对应的parser和lexer
//DONE 分隔符可以是比较运算符

root ::= root_block ?
root_block ::= root_block_item + {
  implements=[
    "icu.windea.pls.script.psi.IParadoxScriptBlock"
  ]
  methods=[getValue isEmpty isNotEmpty getComponents]
}
private root_block_item ::= COMMENT | property | value | variable{
  recoverWhile="#auto"
}

//scripted_variable
//should outside of definition declaration
variable ::= variable_name variable_separator variable_value {
  pin=1
  recoverWhile="#auto"
  extends="icu.windea.pls.script.psi.impl.ParadoxScriptStubElementImpl<?>"
  implements=[
    "icu.windea.pls.script.psi.ParadoxScriptNamedElement"
    "icu.windea.pls.script.psi.ParadoxScriptTypedElement"
  ]
  stubClass="icu.windea.pls.script.psi.ParadoxScriptVariableStub"
  methods=[getIcon getName setName getNameIdentifier getTextOffset getValue getUnquotedValue getValueType getPresentation]
}
variable_name ::= AT VARIABLE_NAME_ID{
  methods=[getName]
}
private variable_separator ::= EQUAL_SIGN
variable_value ::= boolean | int | float

//property related
property ::= property_key property_separator property_value {
  pin=1
  recoverWhile="#auto" //当前属性解析失败时，需要跳过继续解析下一个
  extends="icu.windea.pls.script.psi.impl.ParadoxScriptStubElementImpl<?>"
  stubClass="icu.windea.pls.script.psi.ParadoxScriptPropertyStub"
  implements=[
    "icu.windea.pls.script.psi.ParadoxScriptNamedElement"
    "icu.windea.pls.script.psi.ParadoxScriptTypedElement"
    "icu.windea.pls.script.psi.ParadoxDefinitionProperty"
  ]
  methods=[
    getIcon getName setName getNameIdentifier getValue getDepth getBlock 
    getDefinitionType getValueType getConfigExpression
    getPathName getOriginalPathName getParameterMap getPresentation
  ]
}
property_key ::= key_expr {
  implements=[
    "icu.windea.pls.script.psi.ParadoxScriptExpressionElement"
  ] 
  methods=[
    getName setName getValue setValue getNameIdentifier getReference getReferences
    getValueType getConfigExpression
  ]
}
private property_separator ::= EQUAL_SIGN | LT_SIGN | GT_SIGN | LE_SIGN | GE_SIGN | NOT_EQUAL_SIGN
property_value ::= value

//(property) value related
value ::= variable_reference | boolean | int | float | string | color | block | inline_math {
  implements=[
    "icu.windea.pls.script.psi.ParadoxScriptTypedElement"
  ]
  methods=[
    getIcon getValue
    getValueType getConfigExpression
  ]
}
variable_reference ::= AT VARIABLE_REFERENCE_ID {
  extends=value
  implements=[
    "icu.windea.pls.script.psi.IParadoxScriptVariableReference"
  ]
  methods=[getIcon getName setName getReference getValueType]
}
boolean ::= BOOLEAN_TOKEN {
  extends=value
  implements=[
    "com.intellij.psi.PsiLiteralValue"
  ]
  methods=[getBooleanValue getValueType]
}
int ::= INT_TOKEN {
  extends=value
  implements=[
    "com.intellij.psi.PsiLiteralValue"
  ]
  methods=[getValue getIntValue getValueType]
}
float ::= FLOAT_TOKEN {
  extends=value
  implements=[
    "com.intellij.psi.PsiLiteralValue"
  ]
  methods=[getValue getFloatValue getValueType]
}
upper string ::= value_expr {
  extends="icu.windea.pls.script.psi.impl.ParadoxScriptStubElementImpl<?>"
  stubClass="icu.windea.pls.script.psi.ParadoxScriptStringStub"
  implements=[
    "icu.windea.pls.script.psi.ParadoxScriptValue"
    "icu.windea.pls.script.psi.ParadoxScriptExpressionElement"
  ]
  methods=[
    getIcon
    getName setName getValue setValue getNameIdentifier getReference getReferences getStringValue
    getValueType getConfigExpression
  ]
}
color ::= COLOR_TOKEN {
  extends=value
  methods=[getValue getColor setColor getValueType]
}
block ::= LEFT_BRACE block_item * RIGHT_BRACE {
  pin=1
  recoverWhile="#auto"
  extends=value
  implements=[
    "icu.windea.pls.script.psi.IParadoxScriptBlock"
  ]
  methods=[getIcon getValue isEmpty isNotEmpty getComponents getColor setColor getValueType]
}
private block_item ::= COMMENT | property | value | parameter_condition | variable{
  recoverWhile="#auto"
}

//key & value expressions

//key expressions  (various situations)
private key_expr ::= key_parameter_aware_expr | key_literal_expr
private key_parameter_aware_expr ::= KEY_STRING_SNIPPET? parameter (KEY_STRING_SNIPPET parameter)* KEY_STRING_SNIPPET?
private key_literal_expr ::= PROPERTY_KEY_TOKEN | QUOTED_PROPERTY_KEY_TOKEN

//value expressions (various situations)
private value_expr ::= value_parameter_aware_expr | value_literal_expr
private value_parameter_aware_expr ::= VALUE_STRING_SNIPPET? parameter (VALUE_STRING_SNIPPET parameter)* VALUE_STRING_SNIPPET?
private value_literal_expr ::= STRING_TOKEN | QUOTED_STRING_TOKEN

//advanced script syntax
//see: common/scripted_effects/99_advanced_documentation.txt
//see wiki: https://stellaris.paradoxwikis.com/Dynamic_modding

//tag
//should in definition declaration (scripted_effect / scripted_trigger)
//resolved from a string, before any scripted variables, (non-tag) strings and properties

//parameter
//should in definition declaration (script_value / scripted_effect / scripted_trigger)
//currently cannot be surround with double quotes
parameter ::= PARAMETER_START PARAMETER_ID [PIPE (ARG_NUMBER_TOKEN | ARG_STRING_TOKEN)] PARAMETER_END {
  pin=1
  recoverWhile="#auto"
  implements=[
    "icu.windea.pls.script.psi.ParadoxParameter"
  ]
  methods=[getIcon getName setName getNameIdentifier getTextOffset getValue getDefaultValue getValueType getReference]
}

//parameter condition
//should in definition declaration (script_value / scripted_effect / scripted_trigger)
//currently nested parameter_condition is not supported
parameter_condition ::= LEFT_BRACKET parameter_condition_expr parameter_condition_item * RIGHT_BRACKET{
  pin=1
  recoverWhile="#auto"
  implements="com.intellij.psi.PsiListLikeElement"
  methods=[getIcon getExpression isEmpty isNotEmpty getComponents]
}
private parameter_condition_expr ::= NESTED_LEFT_BRACKET parameter_condition_expression NESTED_RIGHT_BRACKET{
  pin=1
  recoverWhile="#auto"
}
parameter_condition_expression ::= NOT_SIGN ? parameter_condition_parameter
parameter_condition_parameter ::= INPUT_PARAMETER_ID {
  implements="icu.windea.pls.script.psi.ParadoxInputParameter"
  methods=[getIcon getName setName getNameIdentifier getTextOffset getReference]
}
private parameter_condition_item ::= COMMENT | property | value

//inline math
//should in definition declaration
//should starts with "@\[" if in specific definition declaration (scripted_effect / scripted_trigger) (TO CHECK)
//only first inline math expression in a scripted effect / trigger is correctly recognized and evaluated
//supported operators: + - * / %
//also support unary operators "+1" "-1", abs operator "| 1 |" and parentheses "( 1 )"
//inline math factor can also be scripted_variable and (if parameter it self is allowed) parameter 
inline_math ::= INLINE_MATH_START inline_math_expr INLINE_MATH_END{
  pin=1
  recoverWhile="#auto"
  extends=value
  methods=[getValue getValueType]
}
private inline_math_expr ::= (inline_math_unary_expression | inline_math_abs_expression | inline_math_par_expression | inline_math_factor) inline_math_bi_expression *
//noinspection BnfUnusedRule
inline_math_expression ::= inline_math_unary_expression | inline_math_abs_expression | inline_math_par_expression | inline_math_bi_expression
inline_math_unary_expression ::= inline_math_unary_op inline_math_unary_expr{
  pin=1
  extends=inline_math_expression
}
private inline_math_unary_op ::= PLUS_SIGN | MINUS_SIGN
private inline_math_unary_expr ::= inline_math_abs_expression | inline_math_par_expression | inline_math_factor
inline_math_abs_expression ::= LABS_SIGN inline_math_abs_expr RABS_SIGN {
  pin=1
  extends=inline_math_expression
}
private inline_math_abs_expr ::= inline_math_expr
inline_math_par_expression ::= LP_SIGN inline_math_par_expr RP_SIGN {
  pin=1
  extends=inline_math_expression
}
private inline_math_par_expr ::= inline_math_expr
left inline_math_bi_expression ::= inline_math_bi_op inline_math_bi_right_factor{
  pin=1
  extends=inline_math_expression
}
private inline_math_bi_op ::= PLUS_SIGN | MINUS_SIGN | TIMES_SIGN | DIV_SIGN | MOD_SIGN
private inline_math_bi_right_factor ::= inline_math_unary_expression | inline_math_abs_expression | inline_math_par_expression | inline_math_factor
inline_math_factor ::= inline_math_number | inline_math_variable_reference | inline_math_parameter
inline_math_number ::= NUMBER_TOKEN { //int | float
  extends=inline_math_factor
  implements=[
    "com.intellij.psi.PsiLiteralValue"
    "icu.windea.pls.script.psi.ParadoxScriptTypedElement"
  ]
  methods=[getValue getValueType]
}
inline_math_variable_reference ::= INLINE_MATH_VARIABLE_REFERENCE_ID { //without prefix "@"
  extends=inline_math_factor
  implements="icu.windea.pls.script.psi.IParadoxScriptVariableReference"
  methods=[getIcon getName setName getReference]
}
inline_math_parameter ::= PARAMETER_START PARAMETER_ID [PIPE ARG_NUMBER_TOKEN] PARAMETER_END {
  extends=inline_math_factor
  pin=1
  implements="icu.windea.pls.script.psi.ParadoxParameter"
  methods=[getIcon getName setName getNameIdentifier getTextOffset getDefaultValue getReference]
}