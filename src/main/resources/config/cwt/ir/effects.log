Effect Documentation:

--------------------

add_state_food - adds food to a State
Supported Scopes: state

--------------------

add_state_modifier - adds a modifier from a State
Supported Scopes: state

--------------------

every_state_province - Iterate through all provinces in a state
every_state_province = { limit = { <triggers> } <effects> }
Supported Scopes: state
Supported Targets: province

--------------------

ordered_state_province - Iterate through all provinces in a state
ordered_state_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: state
Supported Targets: province

--------------------

random_state_province - Iterate through all provinces in a state
random_state_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: state
Supported Targets: province

--------------------

remove_state_modifier - Removes a modifier from a State
Supported Scopes: state

--------------------

set_state_capital - Changes the capital of a state
Supported Scopes: state
Supported Targets: province

--------------------

adapt_family_name - changes scoped characters surname to reflect on their current family
Supported Scopes: character

--------------------

add_as_governor - Character becomes a governor
Supported Scopes: character
Supported Targets: governorship

--------------------

add_character_experience - adds or subtracts experience from a character
Supported Scopes: character

--------------------

add_character_modifier - adds a modifier to a Character
Supported Scopes: character

--------------------

add_corruption - gives (or takes) Corruption to a character
Supported Scopes: character

--------------------

add_friend - Adds a friend to the character
Supported Scopes: character
Supported Targets: character

--------------------

add_gold - gives (or takes) gold to a character
Supported Scopes: character

--------------------

add_health - adds or subtracts health from a character
Supported Scopes: character

--------------------

add_holding - Adds the province as a holding to a character
Supported Scopes: character
Supported Targets: province

--------------------

add_loyal_veterans - Adds Loyal Veterans to a character
Supported Scopes: character

--------------------

add_loyalty - Adds an Loyalty modifier, add_loyalty = X
X is a scripted modifier name. 
Supported Scopes: character

--------------------

add_nickname - gives a nickname to a character
Supported Scopes: character

--------------------

add_party_conviction - adds party conviction for a character
Supported Scopes: character

--------------------

add_popularity - gives (or takes) Popularity to a character
Supported Scopes: character

--------------------

add_prominence - gives (or takes) Prominence to a character
Supported Scopes: character

--------------------

add_rival - Adds a rival to the character
Supported Scopes: character
Supported Targets: character

--------------------

add_ruler_conviction - Adds ruler conviction
Supported Scopes: character

--------------------

add_trait - Adds a trait to a character
Supported Scopes: character

--------------------

add_triggered_character_modifier - adds a cancellable modifier to a Character
Supported Scopes: character

--------------------

adopt - Makes the currently scoped character adopt another character
Supported Scopes: character
Supported Targets: character

--------------------

banish - Banishes a character to another country
Supported Scopes: character
Supported Targets: country

--------------------

change_mercenary_employer - Changes a characters employer, if they are mecenary
Supported Scopes: character
Supported Targets: country

--------------------

clear_ambition - Clear the ambition for this character
Supported Scopes: character

--------------------

death - kills a character, death = { killer = X death_reason = Y }, where X is a character and Y is one of the death reason keys
Supported Scopes: character

--------------------

deify_character - Deifies a character for a given 'deity' and 'country'.
Supported Scopes: character
Supported Targets: country

--------------------

divorce_character - Divorces two characters
Supported Scopes: character
Supported Targets: character

--------------------

end_pregnancy - end a pregnancy
Supported Scopes: character

--------------------

every_character_treasure - Iterate through all character heirlooms
every_character_treasure = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: treasure

--------------------

every_character_unit - units commanded by a character
every_character_unit = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: unit

--------------------

every_child - Iterate through all children
every_child = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_friend - Iterate through all friends
every_friend = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_governor_state - Iterate through all states a governor is governor of
every_governor_state = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: state

--------------------

every_holdings - Iterate through all holdings of a character
every_holdings = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: province

--------------------

every_parent - Executes on every parent
Supported Scopes: character

--------------------

every_rival - Iterate through all Rivals
every_rival = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_sibling - Iterate through all siblings
every_sibling = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

every_support_as_heir - Iterate through all supportasHeir
every_support_as_heir = { limit = { <triggers> } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

force_add_trait - Adds a trait to a character (will show tooltip even if already having the trait)
Supported Scopes: character

--------------------

give_office - Gives a Office to a character
Supported Scopes: character

--------------------

marry_character - Marries two characters
Supported Scopes: character
Supported Targets: character

--------------------

move_country - Moves a character to another country (without message_popups)
Supported Scopes: character
Supported Targets: country

--------------------

move_country_with_message - Moves a character to another country (with message popups)
Supported Scopes: character
Supported Targets: country

--------------------

ordered_character_treasure - Iterate through all character heirlooms
ordered_character_treasure = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: treasure

--------------------

ordered_character_unit - units commanded by a character
ordered_character_unit = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: unit

--------------------

ordered_child - Iterate through all children
ordered_child = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_friend - Iterate through all friends
ordered_friend = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_governor_state - Iterate through all states a governor is governor of
ordered_governor_state = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: state

--------------------

ordered_holdings - Iterate through all holdings of a character
ordered_holdings = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: province

--------------------

ordered_rival - Iterate through all Rivals
ordered_rival = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_sibling - Iterate through all siblings
ordered_sibling = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

ordered_support_as_heir - Iterate through all supportasHeir
ordered_support_as_heir = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: character
Supported Targets: character

--------------------

pay_gold - the scope character pays gold to the target character, pay_gold = { target = X gold = Y }
Supported Scopes: character

--------------------

random_character_treasure - Iterate through all character heirlooms
random_character_treasure = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: treasure

--------------------

random_character_unit - units commanded by a character
random_character_unit = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: unit

--------------------

random_child - Iterate through all children
random_child = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_friend - Iterate through all friends
random_friend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_governor_state - Iterate through all states a governor is governor of
random_governor_state = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: state

--------------------

random_holdings - Iterate through all holdings of a character
random_holdings = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: province

--------------------

random_parent - Executes on a random parent
Supported Scopes: character

--------------------

random_rival - Iterate through all Rivals
random_rival = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_sibling - Iterate through all siblings
random_sibling = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

random_support_as_heir - Iterate through all supportasHeir
random_support_as_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: character
Supported Targets: character

--------------------

remove_all_offices - Removes all Offices from a character
Supported Scopes: character

--------------------

remove_as_governor - Character stops being a governor
Supported Scopes: character

--------------------

remove_as_mercenary - Character stops being a Mercenary
Supported Scopes: character

--------------------

remove_as_researcher - Character stops being a researcher
Supported Scopes: character

--------------------

remove_character_modifier - Removes a modifier from a Character
Supported Scopes: character

--------------------

remove_command - Removes command from a character
Supported Scopes: character

--------------------

remove_friend - Removes a friend from the character
Supported Scopes: character
Supported Targets: character

--------------------

remove_holding - Removes the province as a holding to a character
Supported Scopes: character
Supported Targets: province

--------------------

remove_loyalty - Removes an Loyalty modifier, remove_loyalty = X
X is a scripted modifier name. 
Supported Scopes: character

--------------------

remove_office - Removes a Office from a character
Supported Scopes: character

--------------------

remove_rival - Removes a rival from the character
Supported Scopes: character
Supported Targets: character

--------------------

remove_trait - Removes a trait from a character
Supported Scopes: character

--------------------

remove_triggered_character_modifier - Removes a triggered modifier from a Character
Supported Scopes: character

--------------------

set_ambition - Set the ambition for this character
Supported Scopes: character

--------------------

set_as_minor_character - changes scoped characters family to the minor, making them a 'minor' character
Supported Scopes: character
Supported Targets: character

--------------------

set_character_religion - Set the religion for this character
Supported Scopes: character
Supported Targets: religion

--------------------

set_culture - Set the culture for this character
Supported Scopes: character
Supported Targets: culture

--------------------

set_culture_same_as - sets the culture of the character to be the same as the culture of the target
Supported Scopes: character
Supported Targets: character

--------------------

set_family - Sets the Family of the character
Supported Scopes: character
Supported Targets: family

--------------------

set_firstname - changes the first name of a character
Supported Scopes: character

--------------------

set_home_country - changes country of origin
Supported Scopes: character
Supported Targets: country

--------------------

set_party_leader - sets the leader for a faction in a country
Supported Scopes: character

--------------------

update_character - Forces a reclaculation of a character's modifiers and status
Supported Scopes: character

--------------------

add_legion_history - adds some history for this legion
Supported Scopes: character, unit, legion

--------------------

add_to_legion - add {unit, character} to specific legion. If unit:commander cannot be moved to legion, it will lose its job. If character cannot be moved to legion, the command is invalid.
Supported Scopes: character, unit
Supported Targets: legion

--------------------

disband_legion - creates a legion for governorship without deducting price
Supported Scopes: governorship

--------------------

every_governorship_state - Iterate through all states in a governorship
every_governorship_state = { limit = { <triggers> } <effects> }
Supported Scopes: governorship
Supported Targets: state

--------------------

ordered_governorship_state - Iterate through all states in a governorship
ordered_governorship_state = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: governorship
Supported Targets: state

--------------------

raise_legion - creates a legion for governorship without deducting price
Supported Scopes: governorship
Supported Targets: legion

--------------------

random_governorship_state - Iterate through all states in a governorship
random_governorship_state = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: governorship
Supported Targets: state

--------------------

destroy_treasure - destroys a treasure
Supported Scopes: treasure

--------------------

transfer_treasure_to_character - transfers a treasure from current owner to new owner (character)
Supported Scopes: treasure
Supported Targets: character

--------------------

transfer_treasure_to_country - transfers a treasure from current owner to new owner (country)
Supported Scopes: treasure
Supported Targets: country

--------------------

transfer_treasure_to_province - transfers a treasure from current owner to new owner (province)
Supported Scopes: treasure
Supported Targets: province

--------------------

add_aggressive_expansion - adds or removes aggressive expansion for a country
Supported Scopes: country

--------------------

add_alliance - Country in scope gets an alliance with the target
Supported Scopes: country
Supported Targets: country

--------------------

add_centralization - gives (or takes) centralization to a country
Supported Scopes: country

--------------------

add_country_modifier - adds a modifier from a country
Supported Scopes: country

--------------------

add_guarantee - Country in scope gurantees the target
Supported Scopes: country
Supported Targets: country

--------------------

add_innovation - adds N innovations
Supported Scopes: country

--------------------

add_legitimacy - gives (or takes) Legitimacy to a country
Supported Scopes: country

--------------------

add_manpower - gives (or takes) Manpower to a country
Supported Scopes: country

--------------------

add_military_access - Country in scope gets military access through the target
Supported Scopes: country
Supported Targets: country

--------------------

add_military_experience - gives (or takes) military experience to a country
Supported Scopes: country

--------------------

add_new_family - adds a new family with the specified name (must be valid from culture files)
Supported Scopes: country

--------------------

add_opinion - Adds an opinion modifier, add_opinion = { modifier = X  target = Z  }
X is a scripted modifier name. 
Supported Scopes: country

--------------------

add_party_approval - adds party approval for a country
Supported Scopes: country

--------------------

add_political_influence - gives (or takes) political influence to a country
Supported Scopes: country

--------------------

add_research - adds research for a country { technology = table value = percent(0-100) }
Supported Scopes: country

--------------------

add_stability - gives (or takes) Stability to a country
Supported Scopes: country

--------------------

add_to_war - adds country to target war, target = SCOPE_WAR, attacker = BOOL, leader = BOOL
Supported Scopes: country

--------------------

add_treasury - gives (or takes) Treasury to a country
Supported Scopes: country

--------------------

add_truce - adds a truce for a country towards another country
Supported Scopes: country

--------------------

add_tyranny - gives (or takes) Tyranny to a country
Supported Scopes: country

--------------------

add_war_exhaustion - gives (or takes) war exhaustion to a country
Supported Scopes: country

--------------------

change_country_adjective - changes the adjective of a country
Supported Scopes: country

--------------------

change_country_color - changes the color of a country
Supported Scopes: country

--------------------

change_country_flag - changes the flag of a country
Supported Scopes: country

--------------------

change_country_name - changes the name of a country
Supported Scopes: country

--------------------

change_country_tag - changes the historical tag of a country
Supported Scopes: country

--------------------

change_government - Removes a modifier from a country
Supported Scopes: country

--------------------

change_law - Changes a law in a country
Supported Scopes: country

--------------------

create_character - creates a character in a country
Supported Scopes: country
Supported Targets: character

--------------------

create_country_treasure - creates a treasure in a country
Supported Scopes: country
Supported Targets: treasure

--------------------

create_family - creates a family for the target character
Supported Scopes: country
Supported Targets: character

--------------------

declare_war_with_wargoal - Declares a war between this country and the target country
Supported Scopes: country

--------------------

every_allied_country - Iterate through all allied countries
every_allied_country = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

every_army - Iterate through all armies in a country
every_army = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

every_available_deity - Iterate through all deity that a country can change to
every_available_deity = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: deity

--------------------

every_character - Iterate through all (major + minor) characters in a country
every_character = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: character

--------------------

every_commander - Iterate through all commanders in a country
every_commander = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: character

--------------------

every_countries_at_war_with - Iterate through all countries at war with
every_countries_at_war_with = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

every_country_culture - Iterate through all country cultures in the country
every_country_culture = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: country culture

--------------------

every_country_state - Iterate through all states in a country
every_country_state = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: state

--------------------

every_country_sub_unit - Iterate through all subunits in all units in a country
every_country_sub_unit = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: subunit

--------------------

every_country_treasure - Iterate through all treasures in a country
every_country_treasure = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: treasure

--------------------

every_current_war - Iterate through all current country wars
every_current_war = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: war

--------------------

every_family - Iterate through all families in a country
every_family = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: family

--------------------

every_governorships - Iterate through all governorships of a country
every_governorships = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: governorship

--------------------

every_integrated_culture - Iterate through all integrated country cultures
every_integrated_culture = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: country culture

--------------------

every_legion - legion in country
every_legion = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: legion

--------------------

every_navy - Iterate through all navies in a country
every_navy = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

every_neighbour_country - Iterate through all neighbour countries
every_neighbour_country = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

every_owned_holy_site - All holy sites in a country
every_owned_holy_site = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: province

--------------------

every_owned_province - Iterate through all owned provinces in a country
every_owned_province = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: province

--------------------

every_pantheon_deity - Iterate through all (valid) pantheon deities
every_pantheon_deity = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: deity

--------------------

every_party - Iterate through all existing parties in a country
every_party = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: party

--------------------

every_subject - Iterate through all subject countries
every_subject = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

every_successor - Iterate through all successors in a country
every_successor = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: character

--------------------

every_unit - Iterate through all units in a country
every_unit = { limit = { <triggers> } <effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

imprison - Imprisons the target character as this character's prisoner, imprison = { target = X  }, where X is a character
Supported Scopes: country

--------------------

integrate_country_culture - Integrates a country culture in a country
Supported Scopes: country
Supported Targets: country culture

--------------------

make_subject - makes the target a subject of the current scope
Supported Scopes: country

--------------------

ordered_allied_country - Iterate through all allied countries
ordered_allied_country = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: country

--------------------

ordered_army - Iterate through all armies in a country
ordered_army = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

ordered_available_deity - Iterate through all deity that a country can change to
ordered_available_deity = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: deity

--------------------

ordered_character - Iterate through all (major + minor) characters in a country
ordered_character = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: character

--------------------

ordered_commander - Iterate through all commanders in a country
ordered_commander = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: character

--------------------

ordered_countries_at_war_with - Iterate through all countries at war with
ordered_countries_at_war_with = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: country

--------------------

ordered_country_culture - Iterate through all country cultures in the country
ordered_country_culture = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: country culture

--------------------

ordered_country_state - Iterate through all states in a country
ordered_country_state = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: state

--------------------

ordered_country_sub_unit - Iterate through all subunits in all units in a country
ordered_country_sub_unit = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: subunit

--------------------

ordered_country_treasure - Iterate through all treasures in a country
ordered_country_treasure = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: treasure

--------------------

ordered_current_war - Iterate through all current country wars
ordered_current_war = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: war

--------------------

ordered_family - Iterate through all families in a country
ordered_family = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: family

--------------------

ordered_governorships - Iterate through all governorships of a country
ordered_governorships = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: governorship

--------------------

ordered_integrated_culture - Iterate through all integrated country cultures
ordered_integrated_culture = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: country culture

--------------------

ordered_legion - legion in country
ordered_legion = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: legion

--------------------

ordered_navy - Iterate through all navies in a country
ordered_navy = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

ordered_neighbour_country - Iterate through all neighbour countries
ordered_neighbour_country = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: country

--------------------

ordered_owned_holy_site - All holy sites in a country
ordered_owned_holy_site = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: province

--------------------

ordered_owned_province - Iterate through all owned provinces in a country
ordered_owned_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: province

--------------------

ordered_pantheon_deity - Iterate through all (valid) pantheon deities
ordered_pantheon_deity = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: deity

--------------------

ordered_party - Iterate through all existing parties in a country
ordered_party = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: party

--------------------

ordered_subject - Iterate through all subject countries
ordered_subject = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: country

--------------------

ordered_successor - Iterate through all successors in a country
ordered_successor = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: character

--------------------

ordered_unit - Iterate through all units in a country
ordered_unit = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

pay_price - Pays a Price from a country
Supported Scopes: country

--------------------

random_allied_country - Iterate through all allied countries
random_allied_country = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

random_army - Iterate through all armies in a country
random_army = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

random_available_deity - Iterate through all deity that a country can change to
random_available_deity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: deity

--------------------

random_character - Iterate through all (major + minor) characters in a country
random_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: character

--------------------

random_commander - Iterate through all commanders in a country
random_commander = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: character

--------------------

random_countries_at_war_with - Iterate through all countries at war with
random_countries_at_war_with = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

random_country_culture - Iterate through all country cultures in the country
random_country_culture = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: country culture

--------------------

random_country_state - Iterate through all states in a country
random_country_state = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: state

--------------------

random_country_sub_unit - Iterate through all subunits in all units in a country
random_country_sub_unit = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: subunit

--------------------

random_country_treasure - Iterate through all treasures in a country
random_country_treasure = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: treasure

--------------------

random_current_war - Iterate through all current country wars
random_current_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: war

--------------------

random_family - Iterate through all families in a country
random_family = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: family

--------------------

random_governorships - Iterate through all governorships of a country
random_governorships = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: governorship

--------------------

random_integrated_culture - Iterate through all integrated country cultures
random_integrated_culture = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: country culture

--------------------

random_legion - legion in country
random_legion = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: legion

--------------------

random_navy - Iterate through all navies in a country
random_navy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

random_neighbour_country - Iterate through all neighbour countries
random_neighbour_country = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

random_owned_holy_site - All holy sites in a country
random_owned_holy_site = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: province

--------------------

random_owned_province - Iterate through all owned provinces in a country
random_owned_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: province

--------------------

random_pantheon_deity - Iterate through all (valid) pantheon deities
random_pantheon_deity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: deity

--------------------

random_party - Iterate through all existing parties in a country
random_party = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: party

--------------------

random_subject - Iterate through all subject countries
random_subject = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: country

--------------------

random_successor - Iterate through all successors in a country
random_successor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: character

--------------------

random_unit - Iterate through all units in a country
random_unit = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: country
Supported Targets: unit

--------------------

recalc_succession - forces a recalculation of succession
Supported Scopes: country

--------------------

refund_price - Refunds a Price from a country
Supported Scopes: country

--------------------

release_prisoner - Release the target character if imprisoned, release_prisoner = { target = X  }, where X is a character
Supported Scopes: country

--------------------

release_subject - Makes the target country stop being a subject of the scoped country
Supported Scopes: country
Supported Targets: country

--------------------

remove_country_modifier - Removes a modifier from a country
Supported Scopes: country

--------------------

remove_gurantee - Country in scope stop guranteeing the target
Supported Scopes: country
Supported Targets: country

--------------------

remove_opinion - Removes an opinion modifier, remove_opinion = { modifier = X  target = Z  }
X is a scripted modifier name. 
Supported Scopes: country

--------------------

remove_party_leadership - remove the leader from a party in a country
Supported Scopes: country

--------------------

reverse_add_opinion - Adds an reverse opinion modifier, reverse_add_opinion = { modifier = X target = Z }
X is a scripted modifier name.
Supported Scopes: country

--------------------

set_as_coruler - sets the coruler of a country to the specified character
Supported Scopes: country
Supported Targets: character

--------------------

set_as_ruler - sets the ruler of a country to the specified character
Supported Scopes: country
Supported Targets: character

--------------------

set_capital - Changes the capital of a country
Supported Scopes: country
Supported Targets: province

--------------------

set_country_heritage - Set the heritage of a newly created country
Supported Scopes: country

--------------------

set_country_religion - Sets religion for a country
Supported Scopes: country

--------------------

set_gender_equality - sets gender equality for a country
Supported Scopes: country

--------------------

set_graphical_culture - sets the graphical culture of a country
Supported Scopes: country

--------------------

set_ignore_senate_approval - sets the country to ignore senate approval
Supported Scopes: country

--------------------

set_legion_recruitment - sets legion recruitment ( disabled, capital OR enabled )
Supported Scopes: country

--------------------

set_primary_culture - Sets primary culture for a country
Supported Scopes: country
Supported Targets: culture

--------------------

start_civil_war - starts a civil-war in a country, setting a specified character as its leader
Supported Scopes: country
Supported Targets: character

--------------------

update_allowed_parties - country in scope instantly recalculates its allowed parties
Supported Scopes: country

--------------------

every_party_member - Iterate through all members of a party
every_party_member = { limit = { <triggers> } <effects> }
Supported Scopes: party
Supported Targets: character

--------------------

ordered_party_member - Iterate through all members of a party
ordered_party_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: party
Supported Targets: character

--------------------

pick_random_agenda - picks a new political objective for party
Supported Scopes: party

--------------------

random_party_member - Iterate through all members of a party
random_party_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: party
Supported Targets: character

--------------------

set_party_agenda - sets political objective for party
Supported Scopes: party

--------------------

add_commander - add {character} to this legion.
Supported Scopes: legion
Supported Targets: character

--------------------

add_distinction - add a distinction to a legion
Supported Scopes: legion

--------------------

add_legion_unit - add {character} to this legion.
Supported Scopes: legion
Supported Targets: unit

--------------------

every_legion_commander - commanders in legion
every_legion_commander = { limit = { <triggers> } <effects> }
Supported Scopes: legion
Supported Targets: character

--------------------

every_legion_unit - units in legion
every_legion_unit = { limit = { <triggers> } <effects> }
Supported Scopes: legion
Supported Targets: unit

--------------------

move_legion - moves legion, characters and units to a new country. Merging legions if necessary
Supported Scopes: legion
Supported Targets: governorship

--------------------

ordered_legion_commander - commanders in legion
ordered_legion_commander = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: legion
Supported Targets: character

--------------------

ordered_legion_unit - units in legion
ordered_legion_unit = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: legion
Supported Targets: unit

--------------------

random_legion_commander - commanders in legion
random_legion_commander = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: legion
Supported Targets: character

--------------------

random_legion_unit - units in legion
random_legion_unit = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: legion
Supported Targets: unit

--------------------

remove_commander - remove {character} from this legion.
Supported Scopes: legion
Supported Targets: character

--------------------

remove_distinction - removes a distinction from a specific legion
Supported Scopes: legion

--------------------

remove_legion_unit - remove {unit} from this legion.
Supported Scopes: legion
Supported Targets: unit

--------------------

add_breach - adds/removed a breach to the current siege
Supported Scopes: siege

--------------------

every_neighbor_region - Iterate through all neighbouring regions of a region
every_neighbor_region = { limit = { <triggers> } <effects> }
Supported Scopes: region
Supported Targets: region

--------------------

every_region_area - Iterate through all areas in a region
every_region_area = { limit = { <triggers> } <effects> }
Supported Scopes: region
Supported Targets: area

--------------------

every_region_province - Iterate through all ownable provinces in a region
every_region_province = { limit = { <triggers> } <effects> }
Supported Scopes: region
Supported Targets: province

--------------------

every_region_province_including_unownable - Iterate through all provinces in a region
every_region_province_including_unownable = { limit = { <triggers> } <effects> }
Supported Scopes: region
Supported Targets: province

--------------------

every_region_state - Iterate through all states in a region
every_region_state = { limit = { <triggers> } <effects> }
Supported Scopes: region
Supported Targets: state

--------------------

ordered_neighbor_region - Iterate through all neighbouring regions of a region
ordered_neighbor_region = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: region
Supported Targets: region

--------------------

ordered_region_area - Iterate through all areas in a region
ordered_region_area = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: region
Supported Targets: area

--------------------

ordered_region_province - Iterate through all ownable provinces in a region
ordered_region_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: region
Supported Targets: province

--------------------

ordered_region_province_including_unownable - Iterate through all provinces in a region
ordered_region_province_including_unownable = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: region
Supported Targets: province

--------------------

ordered_region_state - Iterate through all states in a region
ordered_region_state = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: region
Supported Targets: state

--------------------

random_neighbor_region - Iterate through all neighbouring regions of a region
random_neighbor_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: region
Supported Targets: region

--------------------

random_region_area - Iterate through all areas in a region
random_region_area = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: region
Supported Targets: area

--------------------

random_region_province - Iterate through all ownable provinces in a region
random_region_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: region
Supported Targets: province

--------------------

random_region_province_including_unownable - Iterate through all provinces in a region
random_region_province_including_unownable = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: region
Supported Targets: province

--------------------

random_region_state - Iterate through all states in a region
random_region_state = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: region
Supported Targets: state

--------------------

every_area_including_unownable_province - Iterate through all provinces in an area
every_area_including_unownable_province = { limit = { <triggers> } <effects> }
Supported Scopes: area
Supported Targets: province

--------------------

every_area_province - Iterate through all ownable provinces in an area
every_area_province = { limit = { <triggers> } <effects> }
Supported Scopes: area
Supported Targets: province

--------------------

every_area_state - Iterate through all states in an area
every_area_state = { limit = { <triggers> } <effects> }
Supported Scopes: area
Supported Targets: state

--------------------

every_neighbor_area - Iterate through all neighbouring areas of a Area
every_neighbor_area = { limit = { <triggers> } <effects> }
Supported Scopes: area
Supported Targets: area

--------------------

ordered_area_including_unownable_province - Iterate through all provinces in an area
ordered_area_including_unownable_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: area
Supported Targets: province

--------------------

ordered_area_province - Iterate through all ownable provinces in an area
ordered_area_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: area
Supported Targets: province

--------------------

ordered_area_state - Iterate through all states in an area
ordered_area_state = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: area
Supported Targets: state

--------------------

ordered_neighbor_area - Iterate through all neighbouring areas of a Area
ordered_neighbor_area = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: area
Supported Targets: area

--------------------

random_area_including_unownable_province - Iterate through all provinces in an area
random_area_including_unownable_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: area
Supported Targets: province

--------------------

random_area_province - Iterate through all ownable provinces in an area
random_area_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: area
Supported Targets: province

--------------------

random_area_state - Iterate through all states in an area
random_area_state = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: area
Supported Targets: state

--------------------

random_neighbor_area - Iterate through all neighbouring areas of a Area
random_neighbor_area = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: area
Supported Targets: area

--------------------

create_unit - Creates a Unit with a single cohort for a Country given by the current scope.
 The cohort will be of the first defined type in the unit type db.
 Optional properties:
  name [string, defaults to generated name]
  navy [bool, defaults to no]
  mercenary [bool, defaults to no]
  location [Province, defaults to capital of country scope]
  commander [Character, defaults to none]
  attachto [Unit, will not attach by default]
  sub_unit [Subunit type name, defaults to default cohort/ship type]
Supported Scopes: country, legion
Supported Targets: unit

--------------------

add_food - gives (or takes) Food to a unit
Supported Scopes: unit

--------------------

add_loyal_subunit - Adds a subunit to a Unit
Supported Scopes: unit

--------------------

add_morale - gives (or takes) morale to a unit
Supported Scopes: unit

--------------------

add_subunit - Adds a subunit to a Unit
Supported Scopes: unit

--------------------

add_unit_modifier - adds a modifier from a Unit
Supported Scopes: unit

--------------------

change_unit_owner - Destroys the unit from the current scope
Supported Scopes: unit
Supported Targets: country

--------------------

damage_unit_morale_percent - Applies the given morale damage to each Cohort in the unit as a percentage of their current morale
Supported Scopes: unit

--------------------

damage_unit_percent - Applies the given damage to each Cohort in the unit as a percentage of their current strength
Supported Scopes: unit

--------------------

destroy_unit - Destroys the unit from the current scope
Supported Scopes: unit

--------------------

every_sub_unit - Iterate through all subunits in a unit
every_sub_unit = { limit = { <triggers> } <effects> }
Supported Scopes: unit
Supported Targets: subunit

--------------------

lock_unit - Locks a Unit for the specified number of days
Supported Scopes: unit

--------------------

ordered_sub_unit - Iterate through all subunits in a unit
ordered_sub_unit = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: unit
Supported Targets: subunit

--------------------

random_sub_unit - Iterate through all subunits in a unit
random_sub_unit = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: unit
Supported Targets: subunit

--------------------

remove_unit_loyalty - Removes the personal loyalty of all cohorts in a unit
Supported Scopes: unit

--------------------

remove_unit_modifier - Removes a modifier from a Unit
Supported Scopes: unit

--------------------

set_as_commander - sets the commander of a unit to the specified character
Supported Scopes: unit
Supported Targets: character

--------------------

set_unit_size - Sets the number of people in each Cohort in the Unit to the given percentage of maximum
Supported Scopes: unit

--------------------

split_migrants_to - split until specified number of migrant sub-units
Supported Scopes: unit

--------------------

unlock_unit - Unlocks a locked Unit
Supported Scopes: unit

--------------------

kill_pop - Kill the pop in the current scope
Supported Scopes: pop

--------------------

move_pop - moves the pop to target province.
Supported Scopes: pop
Supported Targets: province

--------------------

set_pop_culture - Set the culture for this pop
Supported Scopes: pop
Supported Targets: culture

--------------------

set_pop_culture_same_as - sets the culture of the pop to be the same as the culture of the target
Supported Scopes: pop
Supported Targets: pop

--------------------

set_pop_religion - Set the Religion for this pop
Supported Scopes: pop
Supported Targets: religion

--------------------

set_pop_religion_same_as - sets the Religion of the pop to be the same as the Religion of the target
Supported Scopes: pop
Supported Targets: pop

--------------------

set_pop_type - Set the pop_type for this pop
Supported Scopes: pop

--------------------

add_subunit_morale - gives (or takes) morale to a subunit
Supported Scopes: subunit

--------------------

add_subunit_strength - gives (or takes) Strength to a subunit
Supported Scopes: subunit

--------------------

destroy_subunit - Destroys the unit from the current scope
Supported Scopes: subunit

--------------------

remove_subunit_loyalty - Removes the personal loyalty of a specific subunit
Supported Scopes: subunit

--------------------

set_personal_loyalty - Sets the personal loyalty of a specific subunit to the target character
Supported Scopes: subunit
Supported Targets: character

--------------------

add_prestige - gives (or takes) Prestige to a family
Supported Scopes: family

--------------------

every_family_member - Iterate through all members of a family
every_family_member = { limit = { <triggers> } <effects> }
Supported Scopes: family
Supported Targets: character

--------------------

move_family - Moves a family to another country
Supported Scopes: family
Supported Targets: country

--------------------

ordered_family_member - Iterate through all members of a family
ordered_family_member = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: family
Supported Targets: character

--------------------

random_family_member - Iterate through all members of a family
random_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: family
Supported Targets: character

--------------------

remove_family - Destroys a family, will remove them from the origin country
Supported Scopes: family
Supported Targets: country

--------------------

force_white_peace - Ends a war in a white peace
Supported Scopes: country, war
Supported Targets: war

--------------------

every_war_attacker - Iterate through all attackers in a war
every_war_attacker = { limit = { <triggers> } <effects> }
Supported Scopes: war
Supported Targets: country

--------------------

every_war_defender - Iterate through all war defenders
every_war_defender = { limit = { <triggers> } <effects> }
Supported Scopes: war
Supported Targets: country

--------------------

every_war_participant - Iterate through all war participants
every_war_participant = { limit = { <triggers> } <effects> }
Supported Scopes: war
Supported Targets: country

--------------------

ordered_war_attacker - Iterate through all attackers in a war
ordered_war_attacker = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: war
Supported Targets: country

--------------------

ordered_war_defender - Iterate through all war defenders
ordered_war_defender = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: war
Supported Targets: country

--------------------

ordered_war_participant - Iterate through all war participants
ordered_war_participant = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: war
Supported Targets: country

--------------------

random_war_attacker - Iterate through all attackers in a war
random_war_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: war
Supported Targets: country

--------------------

random_war_defender - Iterate through all war defenders
random_war_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: war
Supported Targets: country

--------------------

random_war_participant - Iterate through all war participants
random_war_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: war
Supported Targets: country

--------------------

remove_from_war - Removes a country from a war, if the country is warleader the war ends in a white peace.
Supported Scopes: war
Supported Targets: country

--------------------

add_building_level - adds one level of the specified Building
Supported Scopes: province

--------------------

add_civilization_value - adds civilisation to a province
Supported Scopes: province

--------------------

add_claim - gives the targetcountry a claim on the province.
Supported Scopes: province
Supported Targets: country

--------------------

add_permanent_province_modifier - adds a permanent modifier from a Province
Supported Scopes: province

--------------------

add_province_modifier - adds a modifier from a Province
Supported Scopes: province

--------------------

add_road_towards - adds a road towards the target
Supported Scopes: province
Supported Targets: province

--------------------

add_state_loyalty - adds state loyalty to a province
Supported Scopes: province

--------------------

add_vfx - Adds VFX effects on the map
Supported Scopes: province

--------------------

begin_great_work_construction - begins construction of a great work
Supported Scopes: province

--------------------

change_province_name - changes the name of a province
Supported Scopes: province

--------------------

create_country - Creates a new country with the current province scope as capital and then scopes to the new country
Supported Scopes: province
Supported Targets: country

--------------------

create_pop - Creates a specific poptype in a province
Supported Scopes: province

--------------------

create_state_pop - Creates a specific poptype with the countrys religion/culture in a province
Supported Scopes: province

--------------------

define_pop - sets up a pop culture/religion/type possible to set.
Supported Scopes: province

--------------------

every_great_work_in_province - Iterate through all great works in a province
every_great_work_in_province = { limit = { <triggers> } <effects> }
Supported Scopes: province
Supported Targets: great_work

--------------------

every_neighbor_province - Iterate through all neighbors of a province
every_neighbor_province = { limit = { <triggers> } <effects> }
Supported Scopes: province
Supported Targets: province

--------------------

every_pops_in_province - Iterate through all pops in a province
every_pops_in_province = { limit = { <triggers> } <effects> }
Supported Scopes: province
Supported Targets: pop

--------------------

every_province_treasure - Iterate through all province treasures
every_province_treasure = { limit = { <triggers> } <effects> }
Supported Scopes: province
Supported Targets: treasure

--------------------

every_unit_in_province - Iterate through all units in a province
every_unit_in_province = { limit = { <triggers> } <effects> }
Supported Scopes: province
Supported Targets: unit

--------------------

finish_great_work_construction - finishes construction of a great work
Supported Scopes: province

--------------------

hide_model - hides dynamic object on map
Supported Scopes: province

--------------------

ordered_great_work_in_province - Iterate through all great works in a province
ordered_great_work_in_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: province
Supported Targets: great_work

--------------------

ordered_neighbor_province - Iterate through all neighbors of a province
ordered_neighbor_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: province
Supported Targets: province

--------------------

ordered_pops_in_province - Iterate through all pops in a province
ordered_pops_in_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: province
Supported Targets: pop

--------------------

ordered_province_treasure - Iterate through all province treasures
ordered_province_treasure = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: province
Supported Targets: treasure

--------------------

ordered_unit_in_province - Iterate through all units in a province
ordered_unit_in_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: province
Supported Targets: unit

--------------------

random_great_work_in_province - Iterate through all great works in a province
random_great_work_in_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: province
Supported Targets: great_work

--------------------

random_neighbor_province - Iterate through all neighbors of a province
random_neighbor_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: province
Supported Targets: province

--------------------

random_pops_in_province - Iterate through all pops in a province
random_pops_in_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: province
Supported Targets: pop

--------------------

random_province_treasure - Iterate through all province treasures
random_province_treasure = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: province
Supported Targets: treasure

--------------------

random_unit_in_province - Iterate through all units in a province
random_unit_in_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: province
Supported Targets: unit

--------------------

remove_building_level - removes one level of the specified Building
Supported Scopes: province

--------------------

remove_claim - removes the targetcountry's claim on the province.
Supported Scopes: province
Supported Targets: country

--------------------

remove_province_deity - removes a provincial deity
Supported Scopes: province

--------------------

remove_province_modifier - Removes a modifier from a Province
Supported Scopes: province

--------------------

remove_vfx - Removes VFX effects on the map
Supported Scopes: province

--------------------

set_as_governor - sets the governor of a province to the specified character
Supported Scopes: province
Supported Targets: character

--------------------

set_city_status - Sets the rank of a city
Supported Scopes: province

--------------------

set_conquered_by - makes the currrent province owned and controlled by the target country
Supported Scopes: province
Supported Targets: country

--------------------

set_controller - makes the currrent province controlled by the target country, if province owner and target are at war
Supported Scopes: province
Supported Targets: country

--------------------

set_owned_by - makes the currrent province owned and controlled by the target country, without incurring any penalties
Supported Scopes: province
Supported Targets: country

--------------------

set_province_deity - adds a provincial deity
Supported Scopes: province
Supported Targets: deity

--------------------

set_trade_goods - Sets the trade goods in a province
Supported Scopes: province

--------------------

show_animated_text - shows a custom text on the map
Supported Scopes: province

--------------------

show_model - shows dynamic object on map
Supported Scopes: province

--------------------

add_country_culture_modifier - adds a modifier to a country culture
Supported Scopes: country culture

--------------------

add_integration_progress - Add integration progress to a country culture
Supported Scopes: country culture

--------------------

remove_country_culture_modifier - Removes a modifier from a country culture
Supported Scopes: country culture

--------------------

set_country_culture_right - Set civic rights to a country culture
Supported Scopes: country culture

--------------------

add_charisma - Adds charisma skill
Supported Scopes: none

--------------------

add_finesse - Adds finesse skill
Supported Scopes: none

--------------------

add_martial - Adds martial skill
Supported Scopes: none

--------------------

add_to_global_variable_list - Adds the event target to a variable list
add_to_variable_list = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

add_to_list - Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain
add_to_list = <string> NOTE, if adding a permanent target to a temporary list, the whole list becomes permanent
Supported Scopes: none

--------------------

add_to_local_variable_list - Adds the event target to a variable list
add_to_variable_list = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

add_to_temporary_list - Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect
add_to_temporary_list = <string> NOTE, if adding a temporary target to a permanent list, the list will stay permanent
Supported Scopes: none

--------------------

add_to_variable_list - Adds the event target to a variable list
add_to_variable_list = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

add_zeal - Adds zeal skill
Supported Scopes: none

--------------------

assert_if - Conditionally cause an assert during run time
assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string
Supported Scopes: none

--------------------

assert_read - Conditionally cause an assert during read time
assert_read = X, where X is yes or the string to be printed in the assert
Supported Scopes: none

--------------------

break - break execution of effects, break = yes/no/boolean event target
Supported Scopes: none

--------------------

break_alliance - country in scope breaks any applicable alliance with the target
Supported Scopes: none
Supported Targets: country

--------------------

break_if - conditionally break execution of effects, break_if = { X }, where X is a trigger
Supported Scopes: none

--------------------

change_global_variable - Changes the value or a numeric variable
change_variable = { name = X operation = Y }
Where X is the name of the numeric variable to modify
Where the valid operations are add, subtract, multiply, divide and modulo
Where Y is a fixed point value, script value or event target of a value type
Supported Scopes: none

--------------------

change_local_variable - Changes the value or a numeric variable
change_variable = { name = X operation = Y }
Where X is the name of the numeric variable to modify
Where the valid operations are add, subtract, multiply, divide and modulo
Where Y is a fixed point value, script value or event target of a value type
Supported Scopes: none

--------------------

change_variable - Changes the value or a numeric variable
change_variable = { name = X operation = Y }
Where X is the name of the numeric variable to modify
Where the valid operations are add, subtract, multiply, divide and modulo
Where Y is a fixed point value, script value or event target of a value type
Supported Scopes: none

--------------------

clamp_global_variable - Clamps a variable the specified max and min
clamp_variable = { name = X max = Y min = Z }
Where X is the name of the variable
Where Y and Z are script values
Supported Scopes: none

--------------------

clamp_local_variable - Clamps a variable the specified max and min
clamp_variable = { name = X max = Y min = Z }
Where X is the name of the variable
Where Y and Z are script values
Supported Scopes: none

--------------------

clamp_variable - Clamps a variable the specified max and min
clamp_variable = { name = X max = Y min = Z }
Where X is the name of the variable
Where Y and Z are script values
Supported Scopes: none

--------------------

clear_global_variable_list - Empties the list
clear_variable_list = variable_name
Supported Scopes: none

--------------------

clear_local_variable_list - Empties the list
clear_variable_list = variable_name
Supported Scopes: none

--------------------

clear_saved_scope - Clears a saved scope from the top scope
save_scope_as = cool_scope -> clear_saved_scope = cool_scope
Supported Scopes: none

--------------------

clear_variable_list - Empties the list
clear_variable_list = variable_name
Supported Scopes: none

--------------------

custom_label - just a tooltip, the scope as object (for grouping, localization)
Supported Scopes: none

--------------------

custom_tooltip - just a tooltip, the scope as subject (for grouping, localization)
Supported Scopes: none

--------------------

debug_log - Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available
Supported Scopes: none

--------------------

debug_log_scopes - Log the current scope to the game log when this effect executes yes = full scope info, no=only current scope
Supported Scopes: none

--------------------

else - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met
if = { limit = { <triggers> } <effects> }
else = { <effects> }
Supported Scopes: none

--------------------

else_if - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met
if = { limit = { <triggers> } <effects> }
else_if = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_active_war - Iterate through all currently active wars
every_active_war = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: war

--------------------

every_area - Iterate through all existing areas
every_area = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: area

--------------------

every_country - Iterate through all existing countries
every_country = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: country

--------------------

every_deity - Iterate through all existing deities
every_deity = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: deity

--------------------

every_ended_war - Iterate through all previous wars
every_ended_war = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: war

--------------------

every_holy_site - All holy sites in a country
every_holy_site = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

every_in_global_list - Iterate through all items in global list. list = name or variable = name
every_in_global_list = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_in_list - Iterate through all items in list. list = name or variable = name
every_in_list = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_in_local_list - Iterate through all items in local list. list = name or variable = name
every_in_local_list = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

every_living_character - Executes on every living character
Supported Scopes: none

--------------------

every_ownable_province - Iterate through all ownable provinces in the world
every_ownable_province = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

every_province - Executes on every province
Supported Scopes: none

--------------------

every_region - Iterate through all existing regions
every_region = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: region

--------------------

every_sea_and_river_zone - Iterate through all sea and river zones in the world
every_sea_and_river_zone = { limit = { <triggers> } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

hidden_effect - Effect not shown in tooltips
Supported Scopes: none

--------------------

if - Executes enclosed effects if limit criteria are met
if = { limit = { <triggers> } <effects> }
Supported Scopes: none

--------------------

make_pregnant - makes a character pregnant
Supported Scopes: none

--------------------

ordered_active_war - Iterate through all currently active wars
ordered_active_war = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: war

--------------------

ordered_area - Iterate through all existing areas
ordered_area = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: area

--------------------

ordered_country - Iterate through all existing countries
ordered_country = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: country

--------------------

ordered_deity - Iterate through all existing deities
ordered_deity = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: deity

--------------------

ordered_ended_war - Iterate through all previous wars
ordered_ended_war = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: war

--------------------

ordered_holy_site - All holy sites in a country
ordered_holy_site = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: province

--------------------

ordered_in_global_list - Iterate through all items in global list. list = name or variable = name
ordered_in_global_list = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none

--------------------

ordered_in_list - Iterate through all items in list. list = name or variable = name
ordered_in_list = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none

--------------------

ordered_in_local_list - Iterate through all items in local list. list = name or variable = name
ordered_in_local_list = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none

--------------------

ordered_ownable_province - Iterate through all ownable provinces in the world
ordered_ownable_province = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: province

--------------------

ordered_region - Iterate through all existing regions
ordered_region = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: region

--------------------

ordered_sea_and_river_zone - Iterate through all sea and river zones in the world
ordered_sea_and_river_zone = {
limit = { <triggers> }
order_by = script_value
position = int
min = int
max = script_value
check_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max
<effects> }
Supported Scopes: none
Supported Targets: province

--------------------

random - a random effect, random = { chance = X modifier = Y effects... }
where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y
Supported Scopes: none

--------------------

random_active_war - Iterate through all currently active wars
random_active_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: war

--------------------

random_area - Iterate through all existing areas
random_area = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: area

--------------------

random_country - Iterate through all existing countries
random_country = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: country

--------------------

random_deity - Iterate through all existing deities
random_deity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: deity

--------------------

random_ended_war - Iterate through all previous wars
random_ended_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: war

--------------------

random_holy_site - All holy sites in a country
random_holy_site = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

random_in_global_list - Iterate through all items in global list. list = name or variable = name
random_in_global_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none

--------------------

random_in_list - Iterate through all items in list. list = name or variable = name
random_in_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none

--------------------

random_in_local_list - Iterate through all items in local list. list = name or variable = name
random_in_local_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none

--------------------

random_list - a random list effect
random_list = { X1 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y1 effect1 } X2 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y2 effect2 } ... }
Selects one effect from the list and fires it. The effects are weighted by numbers X1, X2... (the higher the number, the higher the chance of the effect being picked).
The chances can be modified by optional value modifier lists Y1, Y2... (AKA MTTH)
Supported Scopes: none

--------------------

random_living_character - Executes on a random living character
Supported Scopes: none

--------------------

random_ownable_province - Iterate through all ownable provinces in the world
random_ownable_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

random_province - Executes on a random province
Supported Scopes: none

--------------------

random_region - Iterate through all existing regions
random_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: region

--------------------

random_sea_and_river_zone - Iterate through all sea and river zones in the world
random_sea_and_river_zone = { limit = { <triggers> } (optional) weight = { mtth } <effects> }
Supported Scopes: none
Supported Targets: province

--------------------

remove_from_list - Removes the current scope from a named list remove_from_list = <string>
Supported Scopes: none

--------------------

remove_global_variable - Removes a variable
remove_variable = variable_name
Supported Scopes: none

--------------------

remove_list_global_variable - Removes the target from a variable list
remove_list_variable = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

remove_list_local_variable - Removes the target from a variable list
remove_list_variable = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

remove_list_variable - Removes the target from a variable list
remove_list_variable = { name = X target = Y }
Where X is the name of the variable
Where Y is an event target
Supported Scopes: none

--------------------

remove_local_variable - Removes a variable
remove_variable = variable_name
Supported Scopes: none

--------------------

remove_variable - Removes a variable
remove_variable = variable_name
Supported Scopes: none

--------------------

reset_scoring - Moves a family to another country
Supported Scopes: none
Supported Targets: country

--------------------

round_global_variable - Rounds a variable to the nearest specified value
clamp_variable = { name = X nearest = Y }
Where X is the name of the variable
Where Y is a script value
Supported Scopes: none

--------------------

round_local_variable - Rounds a variable to the nearest specified value
clamp_variable = { name = X nearest = Y }
Where X is the name of the variable
Where Y is a script value
Supported Scopes: none

--------------------

round_variable - Rounds a variable to the nearest specified value
clamp_variable = { name = X nearest = Y }
Where X is the name of the variable
Where Y is a script value
Supported Scopes: none

--------------------

save_scope_as - Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain
save_event_target_as = <string>
Supported Scopes: none

--------------------

save_temporary_scope_as - Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect
save_temporary_event_target_as = <string>
Supported Scopes: none

--------------------

set_global_variable - Sets a variable
set_variable = { name = X value = Y days = Z }
Where X is the name of the variable used to then access it
Where Y is any event target, bool, value, script value or flag (flag:W)
An optional days where Z is the number of days or script value
This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
Supported Scopes: none

--------------------

set_local_variable - Sets a variable
set_variable = { name = X value = Y days = Z }
Where X is the name of the variable used to then access it
Where Y is any event target, bool, value, script value or flag (flag:W)
An optional days where Z is the number of days or script value
This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
Supported Scopes: none

--------------------

set_variable - Sets a variable
set_variable = { name = X value = Y days = Z }
Where X is the name of the variable used to then access it
Where Y is any event target, bool, value, script value or flag (flag:W)
An optional days where Z is the number of days or script value
This variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope
Supported Scopes: none

--------------------

show_as_tooltip - Effect only shown in tooltips (but not executed)
Supported Scopes: none

--------------------

switch - Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.
switch = {
	trigger = simple_assign_trigger
	case_1 = { <effects> }
	case_2 = { <effects> }
	case_n = { <effects> }
	fallback = { <effects> }
Supported Scopes: none

--------------------

trigger_event - triggers an event or on_action
trigger_event = { id = X days/months/years = Y } (for events)
or
trigger_event = { on_action = X days/months/years = Y } (for on_actions)
Days/months/years are optional and equal to 0 if not specified. If specified, Y can be a value or an inclusive interval "{ A B }" from which the duration will be picked randomly.
Supported Scopes: none

--------------------

while - Repeats enclosed effects while limit criteria are met or until set iteration count is reached
while = { limit = { <triggers> } <effects> }
 while = { count = 3 <effects> }
Default max of 1000.
Supported Scopes: none
