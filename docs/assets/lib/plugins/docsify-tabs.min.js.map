{"version":3,"file":"docsify-tabs.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n    tabsContainer  : 'content',\n    tabBlock       : 'docsify-tabs',\n    tabButton      : 'docsify-tabs__tab',\n    tabButtonActive: 'docsify-tabs__tab--active',\n    tabContent     : 'docsify-tabs__content'\n};\nconst regex = {\n    // Matches markdown code blocks (inline and multi-line)\n    // Example: ```text```\n    codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n    // Matches tab replacement comment\n    // 0: Match\n    // 1: Replacement HTML\n    commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*) -->`),\n\n    // Matches tab set by start/end comment\n    // 0: Match\n    // 1: Indent\n    // 2: Start comment: <!-- tabs:start -->\n    // 3: Labels and content\n    // 4: End comment: <!-- tabs:end -->\n    tabBlockMarkup: /[\\r\\n]*(\\s*)(<!-+\\s+tabs:\\s*?start\\s+-+>)[\\r\\n]+([\\s|\\S]*?)[\\r\\n\\s]+(<!-+\\s+tabs:\\s*?end\\s+-+>)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: <!-- tab:Label -->\n    // 2: Content\n    tabCommentMarkup: /[\\r\\n]*(\\s*)<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]*\\s*(?=<!-+\\s+tabs?:(?!replace))/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: #### **Label** OR #### __Label__\n    // 2: Content\n    tabHeadingMarkup: /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n    persist    : true,\n    sync       : true,\n    theme      : 'classic',\n    tabComments: true,\n    tabHeadings: true\n};\n\n\n// Functions\n// =============================================================================\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content) {\n    const codeBlockMatch   = content.match(regex.codeMarkup) || [];\n    const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n        const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n        // Replace code block with marker to ensure tab markup within code\n        // blocks is not processed. These markers are replaced with their\n        // associated code blocs after tabs have been processed.\n        content = content.replace(item, () => codeMarker);\n\n        return codeMarker;\n    });\n    const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n\n    let tabBlockMatch; // eslint-disable-line no-unused-vars\n    let tabMatch; // eslint-disable-line no-unused-vars\n\n    // Process each tab set\n    while ((tabBlockMatch = regex.tabBlockMarkup.exec(content)) !== null) {\n        let tabBlock            = tabBlockMatch[0];\n        let tabStartReplacement = '';\n        let tabEndReplacement   = '';\n\n        const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlock);\n        const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlock);\n        const tabBlockIndent = tabBlockMatch[1];\n        const tabBlockStart  = tabBlockMatch[2];\n        const tabBlockEnd    = tabBlockMatch[4];\n\n        if (hasTabComments || hasTabHeadings) {\n            tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n            tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n            // Process each tab panel\n            while ((tabMatch = (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlock) : null) || (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlock) : null)) !== null) {\n                const tabTitle   = (tabMatch[2] || '[Tab]').trim();\n                const tabContent = (tabMatch[3] || '').trim();\n\n                // Use replace function to avoid regex special replacement\n                // strings being processed ($$, $&, $`, $', $n)\n                tabBlock = tabBlock.replace(tabMatch[0], () => [\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabTitle.toLowerCase()}\">${tabTitle}</button> -->`,\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabTitle.toLowerCase()}\"> -->`,\n                    `\\n\\n${tabBlockIndent}${tabContent}`,\n                    `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`,\n                ].join(''));\n            }\n        }\n\n        tabBlock = tabBlock.replace(tabBlockStart, () => tabStartReplacement);\n        tabBlock = tabBlock.replace(tabBlockEnd, () => tabEndReplacement);\n        content = content.replace(tabBlockMatch[0], () => tabBlock);\n    }\n\n    // Restore code blocks\n    codeBlockMarkers.forEach((item, i) => {\n        content = content.replace(item, () => codeBlockMatch[i]);\n    });\n\n    return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n    let tabReplaceMatch; // eslint-disable-line no-unused-vars\n\n    while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n        const tabComment     = tabReplaceMatch[0];\n        const tabReplacement = tabReplaceMatch[1] || '';\n\n        html = html.replace(tabComment, () => tabReplacement);\n    }\n\n    return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: the tab containing the\n * matching element ID from the URL, the first tab in the group, or the last tab\n * clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n    const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlocks         = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n    const tabStoragePersist = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n    const tabStorageSync    = JSON.parse(sessionStorage.getItem('*')) || [];\n\n    setActiveTabFromAnchor();\n\n    tabBlocks.forEach((tabBlock, index) => {\n        let activeButton = tabBlock.querySelector(`.${classNames.tabButtonActive}`);\n\n        if (!activeButton) {\n            if (settings.sync && tabStorageSync.length) {\n                activeButton = tabStorageSync\n                    .map(label => tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${label}\"]`))\n                    .filter(elm => elm)[0];\n            }\n\n            if (!activeButton && settings.persist) {\n                activeButton = tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${tabStoragePersist[index]}\"]`);\n            }\n\n            activeButton = activeButton || tabBlock.querySelector(`.${classNames.tabButton}`);\n            activeButton && activeButton.classList.add(classNames.tabButtonActive);\n        }\n    });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm Tab toggle element to mark as active\n */\nfunction setActiveTab(elm, _isMatchingTabSync = false) {\n    const isTabButton = elm.classList.contains(classNames.tabButton);\n\n    if (isTabButton) {\n        const activeButton      = elm;\n        const activeButtonLabel = activeButton.getAttribute('data-tab');\n        const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n        const tabBlock          = activeButton.parentNode;\n        const tabButtons        = Array.apply(null, tabBlock.querySelectorAll(`.${classNames.tabButton}`));\n        const tabBlockOffset    = tabBlock.offsetTop;\n\n        tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n        activeButton.classList.add(classNames.tabButtonActive);\n\n        if (!_isMatchingTabSync) {\n            if (settings.persist) {\n                const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n                const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n                const tabStorage    = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n\n                tabStorage[tabBlockIndex] = activeButtonLabel;\n                sessionStorage.setItem(window.location.href, JSON.stringify(tabStorage));\n            }\n\n            if (settings.sync) {\n                const tabButtonMatches = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`)) : [];\n                const tabStorage       = JSON.parse(sessionStorage.getItem('*')) || [];\n\n                tabButtonMatches.forEach(tabButtonMatch => {\n                    setActiveTab(tabButtonMatch, true);\n                });\n\n                // Maintain position in viewport when tab group's offset changes\n                window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n\n                // Remove existing label if not first in array\n                if (tabStorage.indexOf(activeButtonLabel) > 0) {\n                    tabStorage.splice(tabStorage.indexOf(activeButtonLabel), 1);\n                }\n\n                // Add label if not already in first position\n                if (tabStorage.indexOf(activeButtonLabel) !== 0) {\n                    tabStorage.unshift(activeButtonLabel);\n                    sessionStorage.setItem('*', JSON.stringify(tabStorage));\n                }\n            }\n        }\n    }\n}\n\n/**\n * Sets the active tab based on the anchor ID in the URL\n */\nfunction setActiveTabFromAnchor() {\n    const anchorID              = (window.location.hash.match(/(?:id=)([^&]+)/) || [])[1];\n    const anchorSelector        = anchorID && `.${classNames.tabBlock} #${anchorID.indexOf('%') > -1 ? decodeURIComponent(anchorID) : anchorID}`;\n    const isAnchorElmInTabBlock = anchorID && document.querySelector(anchorSelector);\n\n    if (isAnchorElmInTabBlock) {\n        const anchorElm = document.querySelector(`#${anchorID}`);\n\n        let tabContent;\n\n        if (anchorElm.closest) {\n            tabContent = anchorElm.closest(`.${classNames.tabContent}`);\n        }\n        else {\n            tabContent = anchorElm.parentNode;\n\n            while (tabContent !== document.body && !tabContent.classList.contains(`${classNames.tabContent}`)) {\n                tabContent = tabContent.parentNode;\n            }\n        }\n\n        setActiveTab(tabContent.previousElementSibling);\n    }\n}\n\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n    let hasTabs = false;\n\n    hook.beforeEach(function(content) {\n        hasTabs = regex.tabBlockMarkup.test(content);\n\n        if (hasTabs) {\n            content = renderTabsStage1(content);\n        }\n\n        return content;\n    });\n\n    hook.afterEach(function(html, next) {\n        if (hasTabs) {\n            html = renderTabsStage2(html);\n        }\n\n        next(html);\n    });\n\n    hook.doneEach(function() {\n        if (hasTabs) {\n            setDefaultTabs();\n        }\n    });\n\n    hook.mounted(function() {\n        const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n        tabsContainer && tabsContainer.addEventListener('click', function(evt) {\n            setActiveTab(evt.target);\n        });\n\n        window.addEventListener('hashchange', setActiveTabFromAnchor, false);\n    });\n}\n\n\nif (window) {\n    window.$docsify = window.$docsify || {};\n\n    // Add config object\n    window.$docsify.tabs = window.$docsify.tabs || {};\n\n    // Update settings based on $docsify config\n    Object.keys(window.$docsify.tabs).forEach(key => {\n        if (Object.prototype.hasOwnProperty.call(settings, key)) {\n            settings[key] = window.$docsify.tabs[key];\n        }\n    });\n\n    // Add plugin data\n    window.$docsify.tabs.version = pkgVersion;\n\n    // Init plugin\n    if (settings.tabComments || settings.tabHeadings) {\n        window.$docsify.plugins = [].concat(\n            docsifyTabs,\n            (window.$docsify.plugins || [])\n        );\n    }\n}\n"],"names":["css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","setActiveTab","elm","_isMatchingTabSync","classList","contains","activeButton","activeButtonLabel","getAttribute","querySelector","parentNode","tabButtons","Array","apply","querySelectorAll","tabBlockOffset","offsetTop","forEach","buttonElm","remove","add","tabBlockIndex","indexOf","tabStorage","JSON","parse","sessionStorage","getItem","window","location","href","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","splice","unshift","setActiveTabFromAnchor","anchorID","hash","match","anchorSelector","decodeURIComponent","anchorElm","closest","body","previousElementSibling","$docsify","tabs","Object","keys","key","prototype","hasOwnProperty","call","version","plugins","concat","hook","vm","hasTabs","beforeEach","content","test","tabBlockMatch","tabMatch","codeBlockMatch","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","tabStartReplacement","tabEndReplacement","hasTabComments","hasTabHeadings","tabBlockIndent","tabBlockStart","tabBlockEnd","join","tabTitle","trim","toLowerCase","exec","renderTabsStage1","afterEach","html","next","tabReplaceMatch","tabComment","tabReplacement","renderTabsStage2","doneEach","tabBlocks","tabStoragePersist","tabStorageSync","index","length","label","filter","mounted","addEventListener","evt","target"],"mappings":"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"}