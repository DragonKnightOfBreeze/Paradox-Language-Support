# 评估：索引性能优化（v2.1.3-dev）

> 基于 JFR 性能分析报告（2026-02-19，Stellaris 游戏目录，4GB 内存，索引构建 150s）

## 一、瓶颈总览

索引构建总耗时 121.665s（`IndexInfoAwareFileBasedIndex.indexData`），其中：

| 热点 | 耗时 | 占比 |
|---|---|---|
| `ParadoxMergedIndex.buildData` | 108.722s | 89.4% |
| → `ParadoxParameterIndexInfoSupport.buildData` | 72.856s | 67.0% |
| → `ParadoxConfigManager.getConfigs` | 78.042s | — |
| → → `CwtDefinitionConfigContextProvider.getCacheKey` | **40.444s** | **51.8%** |
| → → → `ParadoxDefinitionInfo.getDeclaration` | 35.791s | — |
| → → → → `ParadoxDefinitionManager.getSubtypeConfigs` | 35.427s | — |
| → → → → → `matchesDefinitionForSubtype` | 33.381s | — |

**核心瓶颈**：`getCacheKey` 为了构建缓存键而调用了 `getDeclaration(options)`，而 `getDeclaration` 本身就是需要被缓存的昂贵操作（**"先有鸡还是先有蛋"问题**）。

## 二、根因分析

### 2.1 getCacheKey 中的昂贵调用

```
CwtDefinitionConfigContextProvider.getCacheKey(context, options)
├─ definitionInfo.getDeclaration(options)        ← 35.791s
│  ├─ getSubtypeConfigs(options)                 ← 遍历所有子类型规则
│  │  └─ matchesDefinitionForSubtype(...)        ← 深度匹配 PSI 结构
│  └─ resolveDeclaration(...)                    ← 深拷贝声明规则树
└─ declarationConfig.declarationConfigCacheKey   ← 提取缓存键
```

`getCacheKey` 的目的是构建一个唯一标识，用于在 `configsCache`（规则分组级缓存）中查找/存储上下文规则。这个标识需要包含声明规则的身份信息（取决于匹配到的子类型）。

**问题所在**：当 `options` 不是 `DEFAULT` 时（索引期间使用 `DUMB`），`getDeclaration` 和 `getSubtypeConfigs` 会**跳过 `CachedValuesManager` 缓存**，每次从头解析：

```kotlin
// ParadoxDefinitionManager.getSubtypeConfigs
return if (finalOptions == ParadoxMatchOptions.DEFAULT) {
    CachedValuesManager.getCachedValue(element, ...) { ... }  // 经过缓存
} else {
    runReadActionSmartly { ... }                                // 不经过缓存！
}
```

### 2.2 影响放大机制

在合并索引构建期间，PSI 树的每个元素都会触发规则解析：

```
buildDataForScriptFile → visitElement(每个元素)
├─ extensionList.forEach { ep.buildData(element, fileData) }  // 所有元素
│  └─ ParadoxParameterIndexInfoSupport.buildData
│     └─ getExpressionReferences → getConfigs → getCacheKey → getDeclaration(DUMB)
└─ (表达式元素)
   └─ getConfigs(element, DUMB) → getCacheKey → getDeclaration(DUMB)
```

对于**同一个定义**内的 N 个元素，`getDeclaration(DUMB)` 会被调用 N 次，每次都重新执行子类型匹配（遍历定义的 PSI 子树）。这意味着：

- **一个有 100 个子属性的定义**：子类型匹配执行 100 次（而非 1 次）
- **Stellaris 游戏目录有数千个定义**：总计数万次冗余的子类型匹配

### 2.3 次要瓶颈

| 热点 | 耗时 | 说明 |
|---|---|---|
| `getConfigContext` | 16.635s | 解析规则上下文（每元素一次，已有 CachedValuesManager 缓存） |
| `getConfigsForConfigContext` 递归 | 7.393s | 递归守卫开销 |
| `ParadoxDefinitionManager.getInfo` | 7.428s | 定义信息解析（PSI 结构遍历） |
| `ParadoxMatchService.matchScriptExpression` | 4.787s | 表达式匹配 |
| `ParadoxMemberService.getPath` | 2.244s | 成员路径解析（PSI 遍历，不可避免） |
| `selectRootFile` | 1.222s | 根文件选择 |

## 三、优化方案评估

### 方案 A：在 getCacheKey 中使用 DEFAULT（可缓存的）选项解析声明规则 ⭐ 推荐

**核心思路**：`getCacheKey` 只需要声明规则的**身份标识**（即 `declarationConfigCacheKey`），不需要关心匹配选项的细微差异。改为使用 `null`（即 DEFAULT）选项调用 `getDeclaration`，利用已有的 `CachedValuesManager` 缓存。

**变更位置**：`CwtDefinitionConfigContextProvider.getCacheKey`

```kotlin
// 当前代码（昂贵）
val declarationConfig = definitionInfo.getDeclaration(options) ?: return null

// 优化后（利用缓存）
val declarationConfig = definitionInfo.getDeclaration(null) ?: return null
```

**正确性论证**：

缓存键格式为：`d@{gameTypeId}#{declarationKey}#{memberPath}\0{memberRole}\0{optionsHash}`

- `declarationKey` 部分：用 DEFAULT 子类型构建，对同一定义始终一致
- `optionsHash` 部分：区分不同匹配选项（DUMB vs DEFAULT），防止缓存冲突
- 即使 DEFAULT 和 DUMB 解析出不同子类型，由于 `optionsHash` 不同，不会产生错误的缓存命中
- 实际规则解析仍在 `getConfigs` 中使用正确的 `options`

**预期收益**：

- `getCacheKey` 从 ~37s 降至 ~1-2s（仅首次调用每个定义时有冷缓存开销）
- 合并索引构建从 ~108s 降至 ~72s（预估，具体取决于其他瓶颈）
- **改动量**：1 行代码

**风险**：**低**。`optionsHash` 后缀保证了不同选项不会互相干扰。

### 方案 B：为 DUMB 模式的子类型解析添加独立缓存

**核心思路**：在 `ParadoxDefinitionManager.getSubtypeConfigs` 中，为 `DUMB` 选项增加一个独立的 `CachedValuesManager` 缓存键。

```kotlin
fun getSubtypeConfigs(definitionInfo: ParadoxDefinitionInfo, options: ParadoxMatchOptions? = null): List<CwtSubtypeConfig> {
    ...
    return when (finalOptions) {
        ParadoxMatchOptions.DEFAULT -> CachedValuesManager.getCachedValue(element, Keys.cachedDefinitionSubtypeConfigs) { ... }
        ParadoxMatchOptions.DUMB -> CachedValuesManager.getCachedValue(element, Keys.cachedDefinitionSubtypeConfigsDumb) { ... }
        else -> runReadActionSmartly { ... } // 其他选项不缓存
    }
}
```

类似地，为 `getDeclaration` 也添加 DUMB 模式缓存。

**预期收益**：

- 所有 DUMB 模式的子类型/声明解析都只执行一次（每定义）
- 与方案 A 互补：方案 A 避免了 getCacheKey 的开销，方案 B 避免了 getConfigs 中可能的 DUMB 解析开销

**风险**：**低**。DUMB 选项在索引期间是确定的，缓存结果在 PSI 不变时有效。

**改动量**：~20 行，涉及 `ParadoxDefinitionManager`。

### 方案 C：在 buildDataForScriptFile 中预热定义级缓存

**核心思路**：在 PSI 遍历时，遇到定义元素时预先解析其子类型和声明规则，确保后续子元素访问时都能命中缓存。

```kotlin
if (element is ParadoxDefinitionElement) {
    val definitionInfo = element.definitionInfo
    if (definitionInfo != null) {
        // 预热缓存
        definitionInfo.getSubtypeConfigs(null)  // DEFAULT，触发缓存
        definitionInfo.getDeclaration(null)      // DEFAULT，触发缓存
        definitionInfoStack.addLast(definitionInfo)
    }
}
```

**预期收益**：确保定义级缓存在子元素遍历前就已填充。

**风险**：**极低**。仅提前触发已有的缓存逻辑。

**改动量**：~3 行，位于 `ParadoxMergedIndex.buildDataForScriptFile`。

**注意**：此方案仅在方案 A 实施后有意义（否则 getCacheKey 仍会调用 DUMB 版本的 getDeclaration）。

### 方案 D（远期）：将子类型计算与声明规则深拷贝解耦

**核心思路**：重构 `getCacheKey`，使其直接从 `definitionInfo` 获取子类型列表来构建缓存键，而不通过 `getDeclaration` 间接获取。

```kotlin
override fun getCacheKey(context: CwtConfigContext, options: ParadoxMatchOptions?): String? {
    val gameTypeId = context.gameType.id
    val definitionInfo = context.definitionInfo ?: return null
    val declarationConfig = definitionInfo.declarationConfig ?: return null // 原始声明规则（非深拷贝）
    val subtypeConfigs = definitionInfo.getSubtypeConfigs(null) // DEFAULT，利用缓存
    val subtypesToDistinct = declarationConfig.subtypesUsedInDeclaration
    val subtypes = subtypeConfigs.mapNotNull { c -> c.name.takeIf { it in subtypesToDistinct } }
    val typeString = buildString {
        append(definitionInfo.type)
        for (subtype in subtypes) append('.').append(subtype)
    }
    val memberPath = context.memberPath ?: return null
    val memberRole = context.memberRole
    val suffix = "${memberPath}\u0000${memberRole.ordinal}\u0000${options.orDefault().toHashString()}"
    return "d@$gameTypeId#$typeString#$suffix"
}
```

**优势**：完全避免调用 `getDeclaration`（包括声明规则树的深拷贝），只计算子类型。

**劣势**：

- 需要确保与 `CwtBaseDeclarationConfigContextProvider.getCacheKey` 的键格式兼容
- 需要考虑 `CwtGameRuleDeclarationConfigContextProvider` / `CwtOnActionDeclarationConfigContextProvider` 等特殊情况
- 改动较大，需要额外的兼容性验证

**风险**：**中等**。需要验证各 `CwtDeclarationConfigContextProvider` 的键格式一致性。

## 四、推荐实施策略

### 第一阶段（立即可行，预期节省 ~35s）

1. **实施方案 A**：将 `getCacheKey` 中的 `getDeclaration(options)` 改为 `getDeclaration(null)`
2. **实施方案 C**：在 `buildDataForScriptFile` 中预热定义级缓存

### 第二阶段（可选，预期额外节省 ~5-10s）

3. **实施方案 B**：为 DUMB 模式添加独立的子类型/声明缓存

### 第三阶段（远期重构）

4. **考虑方案 D**：彻底解耦子类型计算与声明规则深拷贝

### 预期效果

| 指标 | 优化前 | 方案 A+C | 方案 A+B+C |
|---|---|---|---|
| `getCacheKey` | ~37s | ~2s | ~1s |
| `ParadoxMergedIndex.buildData` | ~108s | ~73s | ~68s |
| 总索引时间 | ~150s | ~115s | ~110s |

## 五、补充观察

### 5.1 不可避免的开销

- **`ParadoxMemberService.getPath`**（2.244s）：需要遍历 PSI 获取成员路径，属于结构性开销。
- **`ParadoxMemberPathBase.normalize`**（1.122s）：路径归一化，不可绕过。
- **`ParadoxDefinitionManager.getInfo`**（7.428s）：定义信息解析，涉及 PSI 结构遍历和类型匹配。

### 5.2 潜在的进一步优化方向（未深入评估）

- **`ParadoxParameterIndexInfoSupport.buildData`**：对所有 `ParadoxParameter`、`ParadoxConditionParameter` 和表达式元素触发引用解析。可考虑更细粒度的过滤（如仅对确实包含参数引用的元素触发）。
- **`matchesDefinitionForSubtype`** 内部的 `properties(inline = true)`：对大型定义遍历所有子属性。可考虑引入早期终止条件或结构化缓存。
- **`configsCache` 的嵌套缓存结构**（`rootFile → cacheKey → configs`）：可评估是否存在 GC 压力或锁竞争。

## 六、相关代码位置

| 文件 | 关键方法 |
|---|---|
| `ep/resolve/config/CwtConfigContextProviders.kt` | `CwtDefinitionConfigContextProvider.getCacheKey` |
| `lang/util/ParadoxDefinitionManager.kt` | `getSubtypeConfigs`, `getDeclaration` |
| `lang/resolve/ParadoxDefinitionService.kt` | `resolveSubtypeConfigs`, `resolveDeclaration` |
| `lang/match/ParadoxConfigMatchService.kt` | `matchesSubtype`, `matchesDefinitionForSubtype` |
| `lang/resolve/ParadoxConfigService.kt` | `getConfigsForConfigContext`, `getConfigForDeclarationConfigContext` |
| `lang/index/ParadoxMergedIndex.kt` | `buildDataForScriptFile` |
| `ep/index/ParadoxIndexInfoSupports.Core.kt` | `ParadoxParameterIndexInfoSupport.buildData` |
| `lang/util/ParadoxExpressionManager.kt` | `getExpressionReferences` |
