# 评估：索引性能优化（v2.1.3-dev）

> 基于 JFR 性能分析报告（2026-02-19，Stellaris 游戏目录，4GB 内存，索引构建 150s）

## 一、瓶颈总览

索引构建总耗时 121.665s（`IndexInfoAwareFileBasedIndex.indexData`），其中：

| 热点 | 耗时 | 占比 |
|---|---|---|
| `ParadoxMergedIndex.buildData` | 108.722s | 89.4% |
| → `ParadoxParameterIndexInfoSupport.buildData` | 72.856s | 67.0% |
| → `ParadoxConfigManager.getConfigs` | 78.042s | — |
| → → `CwtDefinitionConfigContextProvider.getCacheKey` | **40.444s** | **51.8%** |
| → → → `ParadoxDefinitionInfo.getDeclaration` | 35.791s | — |
| → → → → `ParadoxDefinitionManager.getSubtypeConfigs` | 35.427s | — |
| → → → → → `matchesDefinitionForSubtype` | 33.381s | — |

**核心瓶颈**：`getCacheKey` 为了构建缓存键而调用了 `getDeclaration(options)`，而 `getDeclaration` 本身就是需要被缓存的昂贵操作（**"先有鸡还是先有蛋"问题**）。

## 二、根因分析

### 2.1 getCacheKey 中的昂贵调用

```
CwtDefinitionConfigContextProvider.getCacheKey(context, options)
├─ definitionInfo.getDeclaration(options)        ← 35.791s
│  ├─ getSubtypeConfigs(options)                 ← 遍历所有子类型规则
│  │  └─ matchesDefinitionForSubtype(...)        ← 深度匹配 PSI 结构
│  └─ resolveDeclaration(...)                    ← 深拷贝声明规则树
└─ declarationConfig.declarationConfigCacheKey   ← 提取缓存键
```

`getCacheKey` 的目的是构建一个唯一标识，用于在 `configsCache`（规则分组级缓存）中查找/存储上下文规则。这个标识需要包含声明规则的身份信息（取决于匹配到的子类型）。

**问题所在**：当 `options` 不是 `DEFAULT` 时（索引期间使用 `DUMB`），`getDeclaration` 和 `getSubtypeConfigs` 会**跳过 `CachedValuesManager` 缓存**，每次从头解析：

```kotlin
// ParadoxDefinitionManager.getSubtypeConfigs
return if (finalOptions == ParadoxMatchOptions.DEFAULT) {
    CachedValuesManager.getCachedValue(element, ...) { ... }  // 经过缓存
} else {
    runReadActionSmartly { ... }                                // 不经过缓存！
}
```

### 2.2 影响放大机制

在合并索引构建期间，PSI 树的每个元素都会触发规则解析：

```
buildDataForScriptFile → visitElement(每个元素)
├─ extensionList.forEach { ep.buildData(element, fileData) }  // 所有元素
│  └─ ParadoxParameterIndexInfoSupport.buildData
│     └─ getExpressionReferences → getConfigs → getCacheKey → getDeclaration(DUMB)
└─ (表达式元素)
   └─ getConfigs(element, DUMB) → getCacheKey → getDeclaration(DUMB)
```

对于**同一个定义**内的 N 个元素，`getDeclaration(DUMB)` 会被调用 N 次，每次都重新执行子类型匹配（遍历定义的 PSI 子树）。这意味着：

- **一个有 100 个子属性的定义**：子类型匹配执行 100 次（而非 1 次）
- **Stellaris 游戏目录有数千个定义**：总计数万次冗余的子类型匹配

### 2.3 次要瓶颈

| 热点 | 耗时 | 说明 |
|---|---|---|
| `getConfigContext` | 16.635s | 解析规则上下文（每元素一次，已有 CachedValuesManager 缓存） |
| `getConfigsForConfigContext` 递归 | 7.393s | 递归守卫开销 |
| `ParadoxDefinitionManager.getInfo` | 7.428s | 定义信息解析（PSI 结构遍历） |
| `ParadoxMatchService.matchScriptExpression` | 4.787s | 表达式匹配 |
| `ParadoxMemberService.getPath` | 2.244s | 成员路径解析（PSI 遍历，不可避免） |
| `selectRootFile` | 1.222s | 根文件选择 |

## 三、优化方案评估

### 方案 A：在 getCacheKey 中使用 DEFAULT（可缓存的）选项解析声明规则 ⭐ 推荐

**核心思路**：`getCacheKey` 只需要声明规则的**身份标识**（即 `declarationConfigCacheKey`），不需要关心匹配选项的细微差异。改为使用 `null`（即 DEFAULT）选项调用 `getDeclaration`，利用已有的 `CachedValuesManager` 缓存。

**变更位置**：`CwtDefinitionConfigContextProvider.getCacheKey`

```kotlin
// 当前代码（昂贵）
val declarationConfig = definitionInfo.getDeclaration(options) ?: return null

// 优化后（利用缓存）
val declarationConfig = definitionInfo.getDeclaration(null) ?: return null
```

**正确性论证**：

缓存键格式为：`d@{gameTypeId}#{declarationKey}#{memberPath}\0{memberRole}\0{optionsHash}`

- `declarationKey` 部分：用 DEFAULT 子类型构建，对同一定义始终一致
- `optionsHash` 部分：区分不同匹配选项（DUMB vs DEFAULT），防止缓存冲突
- 即使 DEFAULT 和 DUMB 解析出不同子类型，由于 `optionsHash` 不同，不会产生错误的缓存命中
- 实际规则解析仍在 `getConfigs` 中使用正确的 `options`

**预期收益**：

- `getCacheKey` 从 ~37s 降至 ~1-2s（仅首次调用每个定义时有冷缓存开销）
- 合并索引构建从 ~108s 降至 ~72s（预估，具体取决于其他瓶颈）
- **改动量**：1 行代码

**风险**：**低**。`optionsHash` 后缀保证了不同选项不会互相干扰。

### 方案 B：为 DUMB 模式的子类型解析添加独立缓存

**核心思路**：在 `ParadoxDefinitionManager.getSubtypeConfigs` 中，为 `DUMB` 选项增加一个独立的 `CachedValuesManager` 缓存键。

```kotlin
fun getSubtypeConfigs(definitionInfo: ParadoxDefinitionInfo, options: ParadoxMatchOptions? = null): List<CwtSubtypeConfig> {
    ...
    return when (finalOptions) {
        ParadoxMatchOptions.DEFAULT -> CachedValuesManager.getCachedValue(element, Keys.cachedDefinitionSubtypeConfigs) { ... }
        ParadoxMatchOptions.DUMB -> CachedValuesManager.getCachedValue(element, Keys.cachedDefinitionSubtypeConfigsDumb) { ... }
        else -> runReadActionSmartly { ... } // 其他选项不缓存
    }
}
```

类似地，为 `getDeclaration` 也添加 DUMB 模式缓存。

**预期收益**：

- 所有 DUMB 模式的子类型/声明解析都只执行一次（每定义）
- 与方案 A 互补：方案 A 避免了 getCacheKey 的开销，方案 B 避免了 getConfigs 中可能的 DUMB 解析开销

**风险**：**低**。DUMB 选项在索引期间是确定的，缓存结果在 PSI 不变时有效。

**改动量**：~20 行，涉及 `ParadoxDefinitionManager`。

### 方案 C：在 buildDataForScriptFile 中预热定义级缓存

**核心思路**：在 PSI 遍历时，遇到定义元素时预先解析其子类型和声明规则，确保后续子元素访问时都能命中缓存。

```kotlin
if (element is ParadoxDefinitionElement) {
    val definitionInfo = element.definitionInfo
    if (definitionInfo != null) {
        // 预热缓存
        definitionInfo.getSubtypeConfigs(null)  // DEFAULT，触发缓存
        definitionInfo.getDeclaration(null)      // DEFAULT，触发缓存
        definitionInfoStack.addLast(definitionInfo)
    }
}
```

**预期收益**：确保定义级缓存在子元素遍历前就已填充。

**风险**：**极低**。仅提前触发已有的缓存逻辑。

**改动量**：~3 行，位于 `ParadoxMergedIndex.buildDataForScriptFile`。

**注意**：此方案仅在方案 A 实施后有意义（否则 getCacheKey 仍会调用 DUMB 版本的 getDeclaration）。

### 方案 D（远期）：将子类型计算与声明规则深拷贝解耦

**核心思路**：重构 `getCacheKey`，使其直接从 `definitionInfo` 获取子类型列表来构建缓存键，而不通过 `getDeclaration` 间接获取。

```kotlin
override fun getCacheKey(context: CwtConfigContext, options: ParadoxMatchOptions?): String? {
    val gameTypeId = context.gameType.id
    val definitionInfo = context.definitionInfo ?: return null
    val declarationConfig = definitionInfo.declarationConfig ?: return null // 原始声明规则（非深拷贝）
    val subtypeConfigs = definitionInfo.getSubtypeConfigs(null) // DEFAULT，利用缓存
    val subtypesToDistinct = declarationConfig.subtypesUsedInDeclaration
    val subtypes = subtypeConfigs.mapNotNull { c -> c.name.takeIf { it in subtypesToDistinct } }
    val typeString = buildString {
        append(definitionInfo.type)
        for (subtype in subtypes) append('.').append(subtype)
    }
    val memberPath = context.memberPath ?: return null
    val memberRole = context.memberRole
    val suffix = "${memberPath}\u0000${memberRole.ordinal}\u0000${options.orDefault().toHashString()}"
    return "d@$gameTypeId#$typeString#$suffix"
}
```

**优势**：完全避免调用 `getDeclaration`（包括声明规则树的深拷贝），只计算子类型。

**劣势**：

- 需要确保与 `CwtBaseDeclarationConfigContextProvider.getCacheKey` 的键格式兼容
- 需要考虑 `CwtGameRuleDeclarationConfigContextProvider` / `CwtOnActionDeclarationConfigContextProvider` 等特殊情况
- 改动较大，需要额外的兼容性验证

**风险**：**中等**。需要验证各 `CwtDeclarationConfigContextProvider` 的键格式一致性。

## 四、推荐实施策略

### 第一阶段（立即可行，预期节省 ~35s）

1. **实施方案 A**：将 `getCacheKey` 中的 `getDeclaration(options)` 改为 `getDeclaration(null)`
2. **实施方案 C**：在 `buildDataForScriptFile` 中预热定义级缓存

### 第二阶段（可选，预期额外节省 ~5-10s）

3. **实施方案 B**：为 DUMB 模式添加独立的子类型/声明缓存

### 第三阶段（远期重构）

4. **考虑方案 D**：彻底解耦子类型计算与声明规则深拷贝

### 预期效果

| 指标 | 优化前 | 方案 A+C | 方案 A+B+C |
|---|---|---|---|
| `getCacheKey` | ~37s | ~2s | ~1s |
| `ParadoxMergedIndex.buildData` | ~108s | ~73s | ~68s |
| 总索引时间 | ~150s | ~115s | ~110s |

## 五、补充观察

### 5.1 不可避免的开销

- **`ParadoxMemberService.getPath`**（2.244s）：需要遍历 PSI 获取成员路径，属于结构性开销。
- **`ParadoxMemberPathBase.normalize`**（1.122s）：路径归一化，不可绕过。
- **`ParadoxDefinitionManager.getInfo`**（7.428s）：定义信息解析，涉及 PSI 结构遍历和类型匹配。

### 5.2 潜在的进一步优化方向（未深入评估）

- **`ParadoxParameterIndexInfoSupport.buildData`**：对所有 `ParadoxParameter`、`ParadoxConditionParameter` 和表达式元素触发引用解析。可考虑更细粒度的过滤（如仅对确实包含参数引用的元素触发）。
- **`matchesDefinitionForSubtype`** 内部的 `properties(inline = true)`：对大型定义遍历所有子属性。可考虑引入早期终止条件或结构化缓存。
- **`configsCache` 的嵌套缓存结构**（`rootFile → cacheKey → configs`）：可评估是否存在 GC 压力或锁竞争。

## 六、相关代码位置

| 文件 | 关键方法 |
|---|---|
| `ep/resolve/config/CwtConfigContextProviders.kt` | `CwtDefinitionConfigContextProvider.getCacheKey` |
| `lang/util/ParadoxDefinitionManager.kt` | `getSubtypeConfigs`, `getDeclaration` |
| `lang/resolve/ParadoxDefinitionService.kt` | `resolveSubtypeConfigs`, `resolveDeclaration` |
| `lang/match/ParadoxConfigMatchService.kt` | `matchesSubtype`, `matchesDefinitionForSubtype` |
| `lang/resolve/ParadoxConfigService.kt` | `getConfigsForConfigContext`, `getConfigForDeclarationConfigContext` |
| `lang/index/ParadoxMergedIndex.kt` | `buildDataForScriptFile` |
| `ep/index/ParadoxIndexInfoSupports.Core.kt` | `ParadoxParameterIndexInfoSupport.buildData` |
| `lang/util/ParadoxExpressionManager.kt` | `getExpressionReferences` |

---

# 第二轮评估：subtypeConfigs/declaration 缓存优化后（v2.1.3-dev）

> 基于 JFR 性能分析报告（2026-02-20，同测试环境）

## 一、优化效果确认

### 已实施的优化

将 `ParadoxDefinitionManager.getSubtypeConfigs` 和 `getDeclaration` 改为**始终走缓存**，区分 DEFAULT 和 DUMB 两种缓存键（`cachedSubtypeConfigs` / `cachedSubtypeConfigsDumb`，`cachedDeclaration` / `cachedDeclarationDumb`）。基于 `options.normalized().skipIndex` 判断走哪个缓存。

### 效果

| 指标 | 优化前 | 优化后 | 变化 |
|---|---|---|---|
| 总索引时间（挂钟） | 150s | **90s** | **-40%** |
| `getCacheKey` | 37.045s | **5.247s** | **-86%** |
| `getDeclaration`（in getCacheKey） | 35.791s | **4.099s** | **-89%** |
| `buildDataForScriptFile` | 103.638s | 90.777s | -12% |

`getCacheKey` 不再是主要瓶颈。优化效果与预期一致。

## 二、新瓶颈分布

优化后，原本被 `getCacheKey` 掩盖的其他热点浮出水面：

### 2.1 热点总览

| 热点 | 耗时 | 说明 |
|---|---|---|
| `getExpressionReferences` | 68.285s | 表达式引用解析（跨热点，包含 getConfigs） |
| `getConfigs` | 58.447s | 规则匹配（跨热点） |
| `getConfigContext` | **23.848s** | **规则上下文解析 ← 新的 #1 瓶颈** |
| `CwtConfigSymbolIndex.indexData` | **22.991s** | **CWT 规则符号索引 ← 新发现** |
| `getConfigsForConfigContext` | 14.102s | 上下文规则解析 |
| `ParadoxDefinitionManager.getInfo` | 10.287s | 定义信息解析 |
| `matchScriptExpression` | 4.51s | 表达式匹配 |

### 2.2 调用链分析

```
buildDataForScriptFile (90.777s)
├─ getExpressionReferences (68.285s) ← 每个表达式元素
│  └─ doGetExpressionReferences → getConfigs (52.748s)
│     └─ ParadoxConfigService.getConfigs (51.272s)
│        ├─ getConfigContext (23.766s)          ← #1
│        ├─ getConfigsForConfigContext (14.102s)
│        │  ├─ withRecursionGuard (5.944s)
│        │  ├─ getCacheKey (5.247s)             ← 已优化
│        │  └─ selectRootFile (1.804s)
│        └─ collectCandidates (5.986s)
└─ getInfo (8.36s)

CwtConfigSymbolIndex.indexData (22.991s)      ← 独立热点
└─ resolveConfigType (13.196s)
   └─ matchesAntPattern (9.59s)               ← 30+ 次/元素
```

## 三、新优化方案评估

### 方案 E：替换 `resolveConfigType` 中的 `matchesAntPattern` 为快速字符串操作 ⭐ 推荐

**问题**：`CwtConfigService.resolveConfigType` 在一个 `when` 链中对每个 CWT 元素执行约 **30 次** `matchesAntPattern` 调用。每次调用涉及 `trimFast` + `splitFast('/')` + 递归段匹配。对于最坏情况（匹配到最后一个分支或无匹配），所有 30 个模式都会被尝试。

**观察**：这些模式全部是**静态常量**，且结构极为简单：

| 模式类型 | 示例 | 等价快速判断 |
|---|---|---|
| `"prefix/*"` | `"links/*"` | `path.startsWith("links/") && depth == 2` |
| `"prefix/sub[*]"` | `"types/type[*]"` | `path.startsWith("types/type[") && depth == 2` |
| `"prefix/sub[*]/*"` | `"enums/enum[*]/*"` | `path.startsWith("enums/enum[") && depth == 3` |
| `"prefix/*/*"` | `"dynamic_values/*/*"` | `path.startsWith("dynamic_values/") && depth == 3` |
| `"prefix/sub[*]/**"` | `"types/type[*]/modifiers/**"` | `path.startsWith("types/type[") && path 包含 "/modifiers/"` |

**优化思路**：将 `when` 链改为基于 `configPath` 首段的 `when` 分发 + 深度 / 前缀检查：

```kotlin
fun resolveConfigType(element: CwtMember, file: PsiFile): CwtConfigType? {
    if (element !is CwtProperty && element !is CwtValue) return null
    if (isInternalFile(file)) return null
    val configPath = getConfigPath(element) ?: return null
    if (configPath.isEmpty()) return null
    val path = configPath.path
    val length = configPath.length
    val first = configPath.get(0)

    return when {
        first.startsWith("type") && first.startsWith("types") -> when {
            // types/type[*]
            element is CwtProperty && length == 2 && first == "types" && configPath.get(1).let { it.startsWith("type[") && it.endsWith("]") } -> CwtConfigTypes.Type
            // types/type[*]/subtype[*]
            element is CwtProperty && length == 3 && ... -> CwtConfigTypes.Subtype
            // types/type[*]/modifiers/**
            element is CwtProperty && length >= 4 && ... -> { /* modifier logic */ }
            else -> null
        }
        first.startsWith("enum") -> when {
            // enums/enum[*], enums/complex_enum[*]
            ...
        }
        first.startsWith("alias") -> when {
            // alias[*]
            ...
        }
        // ... 按首字符分发，每个分支只做简单检查
        else -> null
    }
}
```

**预期收益**：

- `matchesAntPattern` 从 9.59s → ~0.5s（消除字符串分割和递归匹配）
- `resolveConfigType` 从 13.196s → ~4s（`getConfigPath` 2.458s + `isInternalFile` 0.902s 不变）
- `CwtConfigSymbolIndex` 从 22.991s → ~14s
- **预期节省 ~9s**

**风险**：**低**。模式是静态的，转换为确定性字符串操作是等价变换。需要为每个模式编写对应的检查逻辑，但逻辑简单且可测试。

**改动量**：~80-120 行（重写 `resolveConfigType` 方法体）。

### 方案 F：优化 `getConfigContext` 中的重复计算

**问题分解**（23.848s）：

| 子操作 | 耗时 | 说明 |
|---|---|---|
| `CwtDefinitionConfigContextProvider.getContext` | 7.379s | 定义上下文提供者 |
| → `selectScope → getDefinitionInfo` | 2.542s | 查找父定义及其信息 |
| → `getMemberPath` | 1.353s | 成员路径计算 |
| → `relativeTo` | 0.984s | 路径相对化 |
| → `normalize` | 0.697s | 路径归一化 |
| `normalize`（外层） | 2.94s | `memberPathFromFile.normalize()` |
| `getPath` | 2.583s | `ParadoxMemberService.getPath` |
| `selectGameType` | 1.148s | 游戏类型选择 |
| `CwtInlineScriptConfigContextProvider.getContext` | 1.476s | 内联脚本上下文提供者 |

**观察**：

1. `normalize()` 出现两次（外层 2.94s + `getContext` 内 0.697s = 3.6s）——`getConfigContext` 在调用 `ep.getContext` 之前已经 normalize 了 `memberPathFromFile`，但 `CwtDefinitionConfigContextProvider.getContext` 内部的 `relativeTo(...).normalize()` 是对 relative path 的 normalize，无法避免。
2. `getPath` (2.583s) 是 PSI 树遍历，属于结构性开销。
3. `selectScope → getDefinitionInfo` (2.542s) 包含向上遍历 PSI 查找父定义。

**可能的优化**：

- **`selectGameType` (1.148s)**：此值在同一文件内不变，可考虑在文件级别缓存或在 `buildDataForScriptFile` 中提前计算并传递。
- **`normalize` (2.94s + 0.697s)**：检查是否存在冗余归一化。外层的 `memberPathFromFile.normalize()` 在每次调用 `getConfigContext` 时都执行，但同一个 PSI 元素的 `getConfigContext` 结果已被 `CachedValuesManager` 缓存。因此这 2.94s 是**冷缓存**的一次性开销，无法继续优化。
- **`getDefinitionInfo` (2.542s)**：查找父定义需要遍历 PSI 树。考虑到 `buildDataForScriptFile` 已经维护了 `definitionInfoStack`，如果能将当前定义信息传入上下文解析，可以避免重复查找。但这需要修改 `getConfigContext` 接口。

**预期收益**：有限（~2-3s），因为大部分开销是 PSI 遍历的结构性成本。

**风险**：**中等**。修改 `getConfigContext` 接口影响面较大。

**改动量**：中等，取决于具体优化点。

### 方案 G：减少 `withRecursionGuard` 开销 (5.944s)

**问题**：`getConfigsForConfigContext` 使用 `withRecursionGuard` + `withRecursionCheck` 防止递归和冻结。这引入了 `ThreadLocal` 访问和哈希查找开销。

**观察**：在索引构建期间，规则解析的递归深度有限（定义嵌套通常不超过 5-10 层）。`withRecursionGuard` 的 5.944s 主要是高频调用的累积开销。

**可能的优化**：

- 评估是否可以在索引期间使用更轻量的递归检查机制（如基于 `definitionInfoStack` 深度的简单检查）。
- 但这需要确保不引入递归问题。

**预期收益**：~2-3s。

**风险**：**较高**。递归守卫是安全机制，简化可能引入问题。

### 方案 H：减少 `selectRootFile` 开销 (1.804s)

**问题**：每次 `getConfigsForConfigContext` 都调用 `selectRootFile`，即使同一文件内所有元素的根文件相同。

**可能的优化**：在文件级别缓存根文件结果。

**预期收益**：~1-1.5s。

**风险**：**低**。

## 四、推荐实施策略

### 第一优先级（预期节省 ~9s）

- **方案 E**：替换 `resolveConfigType` 中的 `matchesAntPattern` 为快速字符串操作

### 第二优先级（预期节省 ~2-3s）

- **方案 H**：缓存 `selectRootFile` 结果
- **方案 F（部分）**：评估 `selectGameType` 的文件级缓存可行性

### 观察项（暂不建议实施）

- **方案 F（getConfigContext 整体）**：大部分是 PSI 结构性开销，优化空间有限
- **方案 G**：递归守卫开销 5.9s，优化风险较高

### 预期效果

| 指标 | 当前 | 方案 E | 方案 E+H |
|---|---|---|---|
| `resolveConfigType` | ~13s | ~4s | ~4s |
| `selectRootFile` | ~1.8s | ~1.8s | ~0.3s |
| 总索引时间（挂钟） | ~90s | ~81s | ~80s |

## 五、剩余结构性开销分析

以下开销是 PSI 遍历和规则匹配的固有成本，优化空间有限：

| 热点 | 耗时 | 性质 |
|---|---|---|
| `getConfigContext` PSI 遍历 | ~15s | 每元素的定义/路径查找 |
| `getInfo` 定义信息解析 | ~10s | 类型匹配 + PSI 结构 |
| `collectCandidates` | ~6s | 匹配管线（表达式匹配） |
| `getConfigsCacheFromCache` | ~5s | CachedValuesManager 开销 |
| `matchScriptExpression` | ~4.5s | 规则表达式匹配 |
| `collectReferences` | ~5s | 引用收集 |

这些合计约 **45s**，构成了当前架构下的性能下限。进一步大幅优化需要考虑更深层的架构变更（如将部分规则匹配下沉到 stub 索引层、或引入增量索引）。

## 六、相关代码位置（新增）

| 文件 | 关键方法 |
|---|---|
| `config/config/CwtConfigService.kt` | `resolveConfigType`（方案 E） |
| `core/match/AntMatcher.kt` | `matches`（被 resolveConfigType 调用） |
| `lang/_extensions.kt` | `selectRootFile`（方案 H） |
| `lang/resolve/ParadoxConfigService.kt` | `getConfigContext`（方案 F） |
