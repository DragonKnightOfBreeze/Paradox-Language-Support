# 笔记：代码规范

## 命名

如何命名 EP 的实现类：

- 建议格式：`[Domain][Layer][ImplementationType][Role]`
  - `[Domain]` - 领域前缀，如 `Cwt` `Paradox` `Stellaris`
  - `[Layer]` - 分层限定，如 `Base` `Core` `Default`
  - `[ImplementationType]` - 具体的实现类型，暗示实现逻辑
  - `[Role]`  - 角色名，EP 接口名的核心部分，如 `ExpressionSupport`
  - 始终“领域优先”，确保自然分组
- 关于各种实现：
  - `Default`  - 默认实现，适用于唯一默认的场景，或者比后续实现更一般的场景
  - `Base`  - 基础实现，适用于存在内置的核心实现或扩展实现的场合
  - `Core` - 核心实现，同样内置，但是相比基础实现要更高级
- 抽象类：
  - 可以考虑把 `Base` 放到最后，如 `ParadoxScriptExpressionSupportBase`

如何命名拥有特定用途的接口：

- 可感知某一领域模型
  - `*Aware`
- 用于在语义级别解析特定领域模型（规则、表达式等）
  - `*Resolver`
  - `*.Resolver`
- 用于提供仅适用于特定组件的工具方法（包括扩展方法）
  - ~~`*ImplExtensions`~~
  - `*Scope` - 限定作用域，仅限内部使用
  - `*Mixin` - 混入，功能集，特性组合

计算（calculate） VS 评估/求值（evaluate）：
- 求值内联数学表达式（inlineMathExpression）：应当使用 evaluate，因为涉及到参数解析和上下文
- 求值触发器（trigger）：使用 evaluate，这还需要将动态的游戏数据加入上下文

## 导入

- 尽可能地使用显式导入。除非需要导入 DSL 等特殊情况。
- 将星号导入的上限设为50.

优先使用星号导入的包名（包含子包）：

- `com.intellij.ui.dsl` - IntelliJ UI DSL
- `org.junit.Assert.*` - JUNIT 断言
- `icu.windea.pls.config.select` - DSL
- `icu.windea.pls.lang.psi.select` - DSL
- `icu.windea.pls.lang.resolve.complexExpression.dsl` - DSL
- （待补充）

## 缓存机制

- 优先使用 `icu.windea.pls.core.util.CachesKt.CacheBuilder` 构建缓存。
- 优先使用 `com.github.benmanes.caffeine.cache.Interner` 去重字符串。
- `icu.windea.pls.core` 中的全局缓存，一般使用强引用的值，同时指定上限和超时。
- 规则对象这类可能数据量巨大的缓存，一般使用软引用的值。
- 与 IDE 生命周期相关的缓存，一般使用软引用的值。

## 代码结构

关于入口包名的区别：

- `icu.windea.pls.core` - 这里的代码一般是对标准库、平台或第三方库的扩展。也包括一些定制的组件，例如匹配器、优化器等。
- `icu.windea.pls.config` - 存储与规则、规则分组、规则表达式相关的的代码，包括模型、服务、工具、解析器、操作器等。通常不会依赖游戏或模组文件。
- `icu.windea.pls.tools` - 存储作为工具 API 的代码，例如游戏启动器、规则生成器、游戏日志读取器等。通常不会被视为“语言功能”，不会被插件自身用到，甚至不需要访问分析数据与 PSI。

关于 `icu.windea.pls.lang.match` 和 `icu.windea.pls.lang.resolve`：

- 这里用于存放领域特定的、语义级别的（规则相关）匹配和解析逻辑。
- 这里的代码相对 `icu.windea.pls.lang.util.*Manager` 中的更加底层，后者仅在必要时提取和重构到前者中，大部分仍然可以保留。
- 尽可能仅在这里（一般是在 `*Service` 中）调用涉及匹配和解析逻辑的 EP，而不是在 EP 接口的伴生对象或 `*Manager` 中。
- 为了优化编制和查询索引时的性能，有时需要直接传入 LighterAST，而非 PSI。

关于 `service` `manager` `util` 的区别：

- `service`：更加底层的服务，可以包含领域的分析、匹配或解析逻辑，这些逻辑需要（或者未来可能需要）交给具体的扩展点实现。
- `manager`：更加高层的管理器，可以包含各种可以直接使用的领域方法，这些方法可能需要依赖对应的服务方法。
- `util`：拥有特定用途的工具类，其中的方法可能仅适用于某种特定组件或功能，或者只在少数特定场合才会用到。
- 注意：`service` 和 `manager` 不一定必须声明为 IntelliJ 服务，它们也可以直接声明为 Kotlin 对象。

## 文本格式

关于代码检查的描述文本：
- 作为标识符（名字、类型等）的英文文本应偏好使用反引号括起（而非单引号），除非在末尾的括号中。