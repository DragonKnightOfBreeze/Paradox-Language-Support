# 笔记：代码规范

## 命名

如何命名 EP 的实现类：

* 建议格式：`[Domain][Layer][ImplementationType][Role]`
  * `[Domain]` - 领域前缀，如 `Cwt` `Paradox` `Stellaris`
  * `[Layer]` - 分层限定，如 `Base` `Core` `Default`
  * `[ImplementationType]` - 具体的实现类型，暗示实现逻辑
  * `[Role]`  - 角色名，EP 接口名的核心部分，如 `ExpressionSupport`
  * 始终“领域优先”，确保自然分组
* 关于各种实现：
  * `Default`  - 默认实现，适用于唯一默认的场景，或者比后续实现更一般的场景
  * `Base`  - 基础实现，适用于存在内置的核心实现或扩展实现的场合
  * `Core` - 核心实现，同样内置，但是相比基础实现要更高级
* 抽象类：
  * 可以考虑把 `Base` 放到最后，如 `ParadoxScriptExpressionSupportBase`

如何命名拥有特定用途的接口：

* 可感知某一领域模型
  * `*Aware`
* 用于在语义级别解析特定领域模型（规则、表达式等）
  * `*Resolver`
  * `*.Resolver`
* 用于提供仅适用于特定组件的工具方法（包括扩展方法）
  * ~~`*ImplExtensions`~~
  * `*Scope` - 限定作用域，仅限内部使用
  * `*Mixin` - 混入，功能集，特性组合

## 导入

- 尽可能地使用显式导入。除非需要导入 DSL 等特殊情况。
- 将星号导入的上限设为50.

优先使用星号导入的包名（包含子包）：

- `com.intellij.ui.dsl` - IntelliJ UI DSL
- `org.junit.Assert.*` - JUNIT 断言
- （待补充）

## 缓存机制

- 优先使用 `icu.windea.pls.core.util.CachesKt.CacheBuilder` 构建缓存。
- 优先使用 `com.github.benmanes.caffeine.cache.Interner` 去重字符串。
- `icu.windea.pls.core` 中的全局缓存，一般使用强引用的值，同时指定上限和超时。
- 规则对象这类可能数据量巨大的缓存，一般使用软引用的值。
- 与 IDE 生命周期相关的缓存，一般使用软引用的值。