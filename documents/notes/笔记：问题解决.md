# 笔记：问题解决

## 前端相关（参考文档）

### textMate JSON文件中的正则匹配的问题

- 如果结合 `match` 和 `captures`，`match`用来匹配的是整个范围，`captures`用来匹配的是捕获组（以用来进一步匹配）。
- 如果需要检查不在匹配范围之内的前者和后缀，应使用 `(?<=...)` 和 `(?=...)` 进行匹配。
- 嵌套的 `pattern` 必须与 `start` 和 `end` 一同使用，而非 `match`。

## 后端相关

### 确保能读取到最新的内置规则文件

- 目前的现象是规则文件侧的问题，如果在规则文件打开过的情况下重新打开项目，则会正确刷新
- 如果插件的内置规则文件发生变更，而版本号未变更，IDE会认为插件包中的资源文件并非变更过
- 如果要在不修改插件版本号或者不清空缓存的情况下，保证规则正确刷新，需要保证在解析规则之前同步刷新了内置规则目录
- 而这非常容易导致死锁，也许正确的做法就是在调试时，如果变更了内置规则文件，先清空缓存再调试
- 也许可以通过 `ModificationTracker` 或者索引版本号，强制标记插件包中的资源文件为变更过

已验证的事实：

- 先清空缓存目录 `idea-sandbox/IU-2025.1/system/caches` 再调试 - 可行，但这会触发重新索引
- 更新插件版本号 - 可行，插件包中的资源文件会自动刷新
- 往资源目录中注入时间戳文件 - 不可行，不会自动刷新
- `VfsUtil.markDirtyAndRefresh(false, true, true, file)` - 有效，必须 `markDirty`，且要在合适的位置调用，避免读写锁、死锁和UI冻结的问题
- 在项目启动后的规则数据的预加载全部完成后，重新解析已打开的文件（`PlsCoreManager.reparseFiles`） - 不需要与上述所有可行的方案搭配使用

注意到的点：

- `com.intellij.openapi.vfs.impl.jar.CoreJarVirtualFile.getModificationStamp` -> 这里会始终返回0，与文件修改时间戳无关

正确的解决方案：

```kotlin
// 在 com.intellij.openapi.startup.ProjectActivity.execute 中仅执行一次：
withContext(Dispatchers.EDT) {
    runWithModalProgressBlocking(project, PlsBundle.message("configGroup.refresh.builtin.progressTitle")) {
        builtInConfigRootDirectories.forEach {
            VfsUtil.markDirtyAndRefresh(false, true, true, it)
        }
    }
}
```

### 规则数据可能会被不定期清空的问题

- 用户反映内嵌提示中的中文本地化文本会被不定期回退为英文
- 这里使用的语言环境设置（`CwtLocaleConfig`）来自默认项目的规则数据
- 研究发现默认项目目前基于 `TimedReference`
  - 参见：`com.intellij.openapi.project.impl.DefaultProject`
  - 参见：`com.intellij.openapi.project.impl.DefaultProjectTimed`
  - 参见：`com.intellij.util.TimedReference`
- `DefaultProject` 本身不会被清空，其生命周期是整个应用（`Application`），但 `DefaultProject.delegate` 会被定期清空
- 这说明默认项目的规则数据可能会被不定期清空，需要考虑其他的实现方案，而非直接从默认项目获取服务对象，再获取服务对象上的缓存数据

最终的解决方案：

改为缓存到应用（默认项目的规则数据）或项目（对应项目的规则数据）的用户数据中

### jackson 解析 json 失败的问题

在单元测试通过的情况下，在调试 IDE 时 json 解析失败，而之前并非出现过这种情况

build.gradle.kts 中并未显式声明（且尽可能排除了） jackson 相关的依赖

`ObjectMappers.jsonMapper` 的定义：

```
val jsonMapper by lazy {
    jacksonObjectMapper().apply {
        findAndRegisterModules()
        disable(SerializationFeature.INDENT_OUTPUT)
        enable(JsonGenerator.Feature.IGNORE_UNKNOWN)
        enable(JsonParser.Feature.IGNORE_UNDEFINED)
        disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
    }
}
```

如果仅在 build.gradle.kts 中显式加上以下依赖，且去除 `findAndRegisterModules()`，则可以解决问题。

```
implementation("com.fasterxml.jackson.core:jackson-databind:2.20.0")
implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.20.0")
implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.10")
```

如果仅在 ktorm 依赖中排除 kotlin stdlib 的依赖，则可以解决问题。

```
implementation("org.ktorm:ktorm-core:4.1.1") {
    exclude(group = "org.jetbrains.kotlin")
}
implementation("org.ktorm:ktorm-support-sqlite:4.1.1") {
    exclude(group = "org.jetbrains.kotlin")
}
```

**结论**： 如果要导入额外的依赖，需要尽可能地排除 IntelliJ 中已包含的依赖，例如 kotlin stdlib 和 jackson。

### 关于 JFLEX 优先级规则

先按“最长匹配”选中规则；仅当匹配长度相同，才按规则书写顺序决定优先级。

### 对于 non-declarative 的内嵌提示，使用 `psiSingleReference` 不会自动更改配色

对于 `PresentationFactory.psiSingleReference`，按住 ctrl 并将鼠标放到对应的文本上，不会自动更改配色为 `EditorColors.REFERENCE_HYPERLINK_COLOR`

备注：如果要让鼠标同时变成手形，需要手动调用 `PresentationFactory.withCursorOnHoverWhenControlDown`

调用堆栈：
- `com.intellij.codeInsight.hints.presentation.WithAttributesPresentation#paint` 似乎在切换时未被正确调用
- `com.intellij.codeInsight.hints.presentation.InlayPresentation.paint` 
  - `com.intellij.codeInsight.hints.presentation.PresentationRenderer.paint`
  - `com.intellij.codeInsight.hints.LinearOrderInlayRenderer.paint`
- `com.intellij.codeInsight.hints.InlayContentListener` 这个监听器才会真正重新绘制
- `com.intellij.openapi.editor.impl.InlayImpl.repaint` 这里是重新绘制的方法
  - `com.intellij.openapi.editor.impl.InlayImpl.update` 在这里被调用（如果 `changeFlags` 为0）
- `com.intellij.codeInsight.hints.InlayHintsPass.Companion.postprocessInlay`
- `com.intellij.codeInsight.hints.presentation.RecursivelyUpdatingRootPresentation.paint`

- 按住 ctrl 并将鼠标放到对应的文本上时，确实会调用 `com.intellij.codeInsight.hints.LinearOrderInlayRenderer.paint`
- 此时的 presentation 的堆栈，从 root 开始：
  - `RecursivelyUpdatingRootPresentation`
  - -> `MenuOnClickPresentation`
  - -> `ScaledInsetPresentation`
  - -> `DynamicInsetPresentation`
  - -> `WithAttributesPresentation` （textAttributesKey = INLAY_DEFAULT）
  - -> `RoundWithBackgroundPresentation`
  - -> `InsetPresentation` 
  - -> `ScaledInsetPresentation`
  - -> `SequencePresentation` （`this  =  <hovered><hovered>country   root  =  country`）

结论：
- 在 `WithAttributesPresentation` 中，内层的 `INLAY_DEFAULT` 会覆盖掉外层的 `CTRL_CLICKABLE` 的 `myForeground` 字段（从蓝色覆盖为灰色）
- 如果 `other` 是 `INLAY_DEFAULT`（或者 `INLAY_TEXT_WITHOUT_BACKGROUND`），应当优先使用 `attributes` 进行渲染
- 否则，`PresentationFactory.withReferenceAttributes` 等会无法正常生效

后续：
- 存在一个微妙的问题，如果已经按下 ctrl，再让鼠标进入对应的区域，并不会更改配色。必须要鼠标首先就在区域内才行。
- 应该是由 non-declarative 的内嵌提示的实现代码决定的，影响不大，算了算了

### 对于对应多个 PSI 引用的脚本表达式（如 `religion:catholic`），光标位置的用法高亮可能不正确

对于以下本地化文件片段：

```
l_simp_chinese:
 job_evosymbiont_plural_with_icon: "[calculator_physicist.GetIcon][calculator_biologist.GetIcon][calculator_engineer.GetIcon]$job_evosymbiont_plural$"
```

- 光标放到 `GetIcon` 上时，可能会错误地高亮前面的作用域节点，如 `calculator_physicist`。
- 光标放到 `GetIcon` 的结尾时，可以正确地高亮 `GetIcon`。
- 可能与 `CwtConfigUsagesSearcher` 和 `ParadoxDefinitionUsagesSearcher` 有关。
- 可能需要深入研究 IDE 源码。

分析：
- 似乎第一次点击了某个 PSI 之后会缓存，之后不会再次调用 `referencesSearch`

```
getUsageRanges:66, HighlightUsagesKt (com.intellij.codeInsight.highlighting)
↖com.intellij.codeInsight.daemon.impl.IdentifierHighlightingComputer.highlightReferencesAndDeclarations
↖↖com.intellij.codeInsight.daemon.impl.IdentifierHighlightingComputer#computeRanges
↖↖↖com.intellij.codeInsight.daemon.impl.IdentifierHighlightingManagerImpl.getMarkupData # 缓存是在这里发生的 
↖↖↖↖com.intellij.codeInsight.highlighting.BackgroundHighlighter#updateHighlighted

com.intellij.codeInsight.daemon.impl.IdentifierHighlightingManagerImpl.getMarkupData
# result: IdentifierHighlightingResult(occurrences=[IdentifierOccurrence(range=RangeMarker(53,73) 183004, highlightInfoType=HighlightInfoTypeImpl[severity=ELEMENT_UNDER_CARET, key=IDENTIFIER_UNDER_CARET_ATTRIBUTES])], targets=[RangeMarker(53,81) 183005, RangeMarker(53,73) 183004])
# result 的 occurrences 是 53..73，targets 是 53..81 和 53..73，看起来不对（当前 caretOffset 是77）
# 如果在这里清空缓存，则能得到正确的结果

com.intellij.codeInsight.daemon.impl.IdentifierHighlightingManagerImpl.Companion.containsTargetOffset
# 根据这个方法的逻辑，也许需要缩小 result.targets 的文本范围，仅返回节点的而非整个 PSI 的

com.intellij.codeInsight.daemon.impl.IdentifierHighlightingManagerImpl.getMarkupData L134
-com.intellij.codeInsight.daemon.impl.IdentifierHighlightingComputer.computeRanges L123 在这里创建 IdentifierHighlightingResult
--L101 collectCodeBlockMarkerRanges(myInfos, myTargets) # myTargets 最终来自这里（53..81）
--L106 highlightReferencesAndDeclarations(myInfos, myTargets) # 以及这里（53，73）

com.intellij.codeInsight.daemon.impl.IdentifierHighlightingComputer.collectCodeBlockMarkerRanges # 还是来自 contextElement.getTextRange() （COMMAND_TOKEN，53..81）
```

结论：
- 这里也会把 PSI 的文本范围加入 targets，并且只要当前偏移在其中，就会使用缓存
- 也许对于用字符串表示的 `ParadoxExpressionElement`，不能缓存 `IdentifierHighlightingManagerImpl.IDENT_MARKUP`
- 或者，考虑修改 result.targets，对于特定类型的 PSI，取最小范围

最终可以考虑的解决方案：
- `com.intellij.codeInsight.daemon.impl.IdentifierHighlightingComputer.computeRanges` - 处理返回值

## 测试

### 按条件忽略的测试被不正确地忽略了

应当是配置缓存的问题

- 在执行测试命令之前停止守护进程（`./gradlew --stop`）
- 在测试命令中添加 `--no-configuration-cache`
- 通过添加系统属性来按需忽略测试（`-Dpls.test.include.all=true`）

```shell
./gradlew --stop
./gradlew test --tests "icu.windea.pls.ai.providers.ChatModelProviderTest" --no-configuration-cache
```

### 需要在单元测试（集成测试）中加载并获取规则数据

按需加载指定规则分组的数据。

```kotlin
val configGroup = PlsFacade.getConfigGroup()
runBlocking { configGroup.init() }
// ...

// 或者

val configGroupService = PlsFacade.getConfigGroupService()
val configGroups = configGroupService.getConfigGroups(project)
runBlocking { configGroupService.init(configGroups, project) }
// ...
```