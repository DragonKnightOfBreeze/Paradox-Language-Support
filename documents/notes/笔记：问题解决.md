# 笔记：问题解决

## 前端相关（参考文档）

关于 textMate JSON文件中的正则匹配的问题：

- 如果结合 `match` 和 `captures`，`match`用来匹配的是整个范围，`captures`用来匹配的是捕获组（以用来进一步匹配）。
- 如果需要检查不在匹配范围之内的前者和后缀，应使用 `(?<=...)` 和 `(?=...)` 进行匹配。
- 嵌套的 `pattern` 必须与 `start` 和 `end` 一同使用，而非 `match`。

## 后端相关

### 确保能读取到最新的内置规则文件

- 目前的现象是规则文件侧的问题，如果在规则文件打开过的情况下重新打开项目，则会正确刷新
- 如果插件的内置规则文件发生变更，而版本号未变更，IDE会认为插件包中的资源文件并非变更过
- 如果要在不修改插件版本号或者不清空缓存的情况下，保证规则正确刷新，需要保证在解析规则之前同步刷新了内置规则目录
- 而这非常容易导致死锁，也许正确的做法就是在调试时，如果变更了内置规则文件，先清空缓存再调试
- 也许可以通过 `ModificationTracker` 或者索引版本号，强制标记插件包中的资源文件为变更过

已验证的事实：

- 先清空缓存目录 `idea-sandbox/IU-2025.1/system/caches` 再调试 - 可行，但这会触发重新索引
- 更新插件版本号 - 可行，插件包中的资源文件会自动刷新
- 往资源目录中注入时间戳文件 - 不可行，不会自动刷新
- `VfsUtil.markDirtyAndRefresh(false, true, true, file)` - 有效，必须 `markDirty`，且要在合适的位置调用，避免读写锁、死锁和UI冻结的问题
- 在项目启动后的规则数据的预加载全部完成后，重新解析已打开的文件（`PlsCoreManager.reparseFiles`） - 不需要与上述所有可行的方案搭配使用

注意到的点：

- `com.intellij.openapi.vfs.impl.jar.CoreJarVirtualFile.getModificationStamp` -> 这里会始终返回0，与文件修改时间戳无关

正确的解决方案：

```kotlin
// 在 com.intellij.openapi.startup.ProjectActivity.execute 中仅执行一次：
withContext(Dispatchers.EDT) {
    runWithModalProgressBlocking(project, PlsBundle.message("configGroup.refresh.builtin.progressTitle")) {
        builtInConfigRootDirectories.forEach {
            VfsUtil.markDirtyAndRefresh(false, true, true, it)
        }
    }
}
```

### 规则数据可能会被不定期清空的问题

- 用户反映内嵌提示中的中文本地化文本会被不定期回退为英文
- 这里使用的语言环境设置（`CwtLocaleConfig`）来自默认项目的规则数据
- 研究发现默认项目目前基于 `TimedReference`
  - 参见：`com.intellij.openapi.project.impl.DefaultProject`
  - 参见：`com.intellij.openapi.project.impl.DefaultProjectTimed`
  - 参见：`com.intellij.util.TimedReference`
- `DefaultProject` 本身不会被清空，其生命周期是整个应用（`Application`），但 `DefaultProject.delegate` 会被定期清空
- 这说明默认项目的规则数据可能会被不定期清空，需要考虑其他的实现方案，而非直接从默认项目获取服务对象，再获取服务对象上的缓存数据

最终的解决方案：

改为缓存到应用（默认项目的规则数据）或项目（对应项目的规则数据）的用户数据中

### jackson 解析 json 失败的问题

在单元测试通过的情况下，在调试 IDE 时 json 解析失败，而之前并非出现过这种情况

build.gradle.kts 中并未显式声明（且尽可能排除了） jackson 相关的依赖

`ObjectMappers.jsonMapper` 的定义：

```
val jsonMapper by lazy {
    jacksonObjectMapper().apply {
        findAndRegisterModules()
        disable(SerializationFeature.INDENT_OUTPUT)
        enable(JsonGenerator.Feature.IGNORE_UNKNOWN)
        enable(JsonParser.Feature.IGNORE_UNDEFINED)
        disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
    }
}
```

如果仅在 build.gradle.kts 中显式加上以下依赖，且去除 `findAndRegisterModules()`，则可以解决问题。

```
implementation("com.fasterxml.jackson.core:jackson-databind:2.20.0")
implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.20.0")
implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.10")
```

如果仅在 ktorm 依赖中排除 kotlin stdlib 的依赖，则可以解决问题。

```
implementation("org.ktorm:ktorm-core:4.1.1") {
    exclude(group = "org.jetbrains.kotlin")
}
implementation("org.ktorm:ktorm-support-sqlite:4.1.1") {
    exclude(group = "org.jetbrains.kotlin")
}
```

**结论**： 如果要导入额外的依赖，需要尽可能地排除 IntelliJ 中已包含的依赖，例如 kotlin stdlib 和 jackson。

## 测试

### 按条件忽略的测试被不正确地忽略了

应当是配置缓存的问题

- 在执行测试命令之前停止守护进程（`./gradlew --stop`）
- 在测试命令中添加 `--no-configuration-cache`
- 通过添加系统属性来按需忽略测试（`-Dpls.test.include.all=true`）

```shell
./gradlew --stop
./gradlew test --tests "icu.windea.pls.ai.providers.ChatModelProviderTest" --no-configuration-cache
```

### 需要在单元测试（集成测试）中加载并获取规则数据

按需加载指定规则分组的数据。

```kotlin
val configGroup = PlsFacade.getConfigGroup()
runBlocking { configGroup.init() }
// ...

// 或者

val configGroupService = PlsFacade.getConfigGroupService()
val configGroups = configGroupService.getConfigGroups(project)
runBlocking { configGroupService.init(configGroups, project) }
// ...
```