# 笔记：问题解决

## 后端相关

### 确保能读取到最新的内置规则文件

- 目前的现象是规则文件侧的问题，如果在规则文件打开过的情况下重新打开项目，则会正确刷新
- 如果插件的内置规则文件发生变更，而版本号未变更，IDE会认为插件包中的资源文件并非变更过
- 如果要在不修改插件版本号或者不清空缓存的情况下，保证规则正确刷新，需要保证在解析规则之前同步刷新了内置规则目录
- 而这非常容易导致死锁，也许正确的做法就是在调试时，如果变更了内置规则文件，先清空缓存再调试
- 也许可以通过 `ModificationTracker` 或者索引版本号，强制标记插件包中的资源文件为变更过

已验证的事实：

- 先清空缓存目录 `idea-sandbox/IU-2025.1/system/caches` 再调试 - 可行，但这会触发重新索引
- 更新插件版本号 - 可行，插件包中的资源文件会自动刷新
- 往资源目录中注入时间戳文件 - 不可行，不会自动刷新
- `VfsUtil.markDirtyAndRefresh(false, true, true, file)` - 有效，必须 `markDirty`，且要在合适的位置调用，避免读写锁、死锁和UI冻结的问题
- 在项目启动后的规则数据的预加载全部完成后，重新解析已打开的文件（`PlsCoreManager.reparseFiles`） - 不需要与上述所有可行的方案搭配使用

注意到的点：

- `com.intellij.openapi.vfs.impl.jar.CoreJarVirtualFile.getModificationStamp` -> 这里会始终返回0，与文件修改时间戳无关

正确的解决方案：

```kotlin
// 在 com.intellij.openapi.startup.ProjectActivity.execute 中仅执行一次：
withContext(Dispatchers.EDT) {
    runWithModalProgressBlocking(project, PlsBundle.message("configGroup.refresh.builtin.progressTitle")) {
        builtInConfigRootDirectories.forEach {
            VfsUtil.markDirtyAndRefresh(false, true, true, it)
        }
    }
}
```

### 规则数据可能会被不定期清空的问题

- 用户反映内嵌提示中的中文本地化文本会被不定期回退为英文
- 这里使用的语言环境设置（`CwtLocaleConfig`）来自默认项目的规则数据
- 研究发现默认项目目前基于 `TimedReference`
  - 参见：`com.intellij.openapi.project.impl.DefaultProject`
  - 参见：`com.intellij.openapi.project.impl.DefaultProjectTimed`
  - 参见：`com.intellij.util.TimedReference`
- `DefaultProject` 本身不会被清空，其生命周期是整个应用（`Application`），但 `DefaultProject.delegate` 会被定期清空
- 这说明默认项目的规则数据可能会被不定期清空，需要考虑其他的实现方案，而非直接从默认项目获取服务对象，再获取服务对象上的缓存数据