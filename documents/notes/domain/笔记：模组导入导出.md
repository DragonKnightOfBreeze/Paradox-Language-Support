# 笔记：模组导入导出

## 概述

目前用于：

- 在游戏或模组设置的对话框中，从各种数据文件导入模组信息到模组依赖列表中。
- 在游戏或模组设置的对话框中，从模组依赖列表导出模组信息各种数据文件。

IMM 参考链接：

- https://github.com/bcssov/IronyModManager
- https://github.com/bcssov/IronyModManager/tree/master/src/IronyModManager.IO/Mods/Importers
- https://github.com/bcssov/IronyModManager/tree/master/src/IronyModManager.IO/Mods/Exporter

核心代码：

- `icu.windea.pls.ep.tools` - EP 与模型类所在的包
- `icu.windea.pls.ep.tools.importer.ParadoxLauncherJsonImporter` - 模组导入器 EP
- `icu.windea.pls.ep.tools.exporter.ParadoxLauncherJsonExporter` - 模组导出器 EP
- `icu.windea.pls.lang.ui.tools.ParadoxModDependenciesImportPopup` - 导入模组依赖的弹出窗口 UI
- `icu.windea.pls.lang.ui.tools.ParadoxModDependenciesExportPopup` - 导出模组依赖的弹出窗口 UI

模组导入器实现：

- `icu.windea.pls.ep.tools.importer.ParadoxJsonBasedModImporter` - 基于 JSON 的模组导入器
  - [X] `icu.windea.pls.ep.tools.importer.ParadoxGameJsonImporter` - 基于 `dlc_load.json` 或 `content_load.json`
  - [X] `icu.windea.pls.ep.tools.importer.ParadoxLauncherJsonImporter` - 基于 `playlist.json`，版本：V2（< 2021.10），V3（≥ 2021.10）
- `icu.windea.pls.ep.tools.importer.ParadoxDbBasedModImporter` - 基于 SQLite 的模组导入器
  - [ ] `icu.windea.pls.ep.tools.importer.ParadoxLauncherDbImporter` - 基于 `launcher-v2.sqlite`，版本：V2，V4，V5 
  - [X] `icu.windea.pls.ep.tools.importer.ParadoxLauncherBetaDbImporter` - 基于 `launcher-v2_openbeta.sqlite`，版本：V2，V4，V5

模组导出器实现：

- `icu.windea.pls.ep.tools.exporter.ParadoxJsonBasedModExporter` - 基于 JSON 的模组导入器
  - [ ] `icu.windea.pls.ep.tools.exporter.ParadoxGameJsonExporter` - 基于 `dlc_load.json` 或 `content_load.json`
  - [ ] `icu.windea.pls.ep.tools.exporter.ParadoxLauncherJsonV2Exporter` - 基于 `playlist.json`，版本：V2（< 2021.10）
  - [ ] `icu.windea.pls.ep.tools.exporter.ParadoxLauncherJsonV3Exporter` - 基于 `playlist.json`，版本：V3（≥ 2021.10）
- `icu.windea.pls.ep.tools.exporter.ParadoxDbBasedModExporter` - 基于 SQLite 的模组导入器
  - [ ] `icu.windea.pls.ep.tools.exporter.ParadoxLauncherDbExporter` - 基于 `launcher-v2.sqlite`，版本：V2，V4，V5
  - [X] `icu.windea.pls.ep.tools.exporter.ParadoxLauncherBetaDbExporter` - 基于 `launcher-v2_openbeta.sqlite`，版本：V2，V4，V5

## 如何优雅且可选择性地排除 sqlite 依赖

### 目标与约束

- 目标：在最终打包插件时，能够优雅地“去除 SQLite 依赖”并隐藏基于 SQLite 的导入/导出器；也可以保留依赖或同时发布两个版本；测试代码仍保留依赖并可运行。
- 约束：不修改任何文件（本次仅提供方案与示例配置/代码片段）。

---

### 可选方案一：单插件双变体（推荐起步）

- 思路
  - 通过 Gradle 属性控制是否把 `sqlite-jdbc` 打进插件产物。
  - 生产两种构建产物：Full（带 SQLite）/ Lite（不带 SQLite）。
  - 运行期通过“类存在性”探测来隐藏/禁用 SQLite 相关功能（动作、菜单项等）。
  - 测试保持 `testImplementation` 依赖，不受打包产物控制。

- 构建层（Gradle）建议
  - 在 `build.gradle.kts` 中用项目属性开关：
    - `-PincludeSqlite=true|false` 控制是否添加 `runtimeOnly("org.xerial:sqlite-jdbc:...")`
    - 始终保留 `testImplementation("org.xerial:sqlite-jdbc:...")`，保证测试不受影响
  - 自定义两个任务或用属性触发：
    - Full：`.\gradlew buildPlugin -PincludeSqlite=true`
    - Lite：`.\gradlew buildPlugin -PincludeSqlite=false`
  - 构建时动态修改版本号或产物名称（例如在 `patchPluginXml` 中对版本号追加 `-lite` 后缀）便于发布两种变体

- 运行期能力探测（避免 ClassNotFoundException）
  - 新增一个能力判断工具（示例）：
    - `object ParadoxCapabilities { fun hasSqlite(): Boolean = try { Class.forName("org.sqlite.JDBC"); true } catch (_: Throwable) { false } }`
  - 使用点：
    - 在基于 SQLite 的导入/导出动作（`AnAction`）的 `update()` 方法里：
      - `presentation.isEnabledAndVisible = ParadoxCapabilities.hasSqlite()`
    - 在导入/导出器的入口 [execute()](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/exporter/ParadoxGameJsonExporter.kt:28:4-66:5) 开头做一次短路判断：
      - 若 `!hasSqlite()`，直接提示“当前构建不包含 SQLite 支持”（通知气泡）并返回
  - 注意点：
    - 不要在静态初始化块中间接触发加载 JDBC 类（只在真正需要连接时才触发）
    - Ktorm 可以保留；真正“重”的是 sqlite-jdbc；Lite 变体仅不打包 sqlite-jdbc 即可

- 测试不受影响
  - 将 sqlite-jdbc 置于 `testImplementation`，即使 Lite 变体打包时不带 jdbc，测试照常运行
  - 本地/CI 资源型测试、集成测试可继续执行

- 发布层
  - GitHub Actions/JetBrains Marketplace 可通过矩阵一次性产出 Full/Lite 两个 zip（Full 默认，Lite 追加 `-lite` 后缀或发布到不同渠道）

- 优点
  - 改动小；保留单一插件工程结构；快速落地
- 缺点
  - Lite 变体仍会包含 Ktorm 等小依赖（但基本可接受）
  - 代码中需要显式做能力探测与 UI 隐藏逻辑

---

### 可选方案二：拆分为“主插件 + 可选的 SQLite 扩展插件”（最佳长期演进）

- 思路
  - 将所有与 SQLite 相关的导入/导出器实现迁移到一个独立插件模块（例如 `pls-sqlite`）
  - 主插件定义导入/导出器的扩展点（EP），SQLite 插件实现这些 EP
  - 用户可单独安装/卸载“SQLite 支持”插件。主插件中若无该扩展，实现自然“缺席”，不存在任何 SQLite 依赖
  - 测试可以分别放在两个模块中；也可单独在 sqlite 插件模块中保留 sqlite-jdbc 依赖

- 插件架构建议
  - 主插件（Core）
    - 定义 EP：例如 [com.your.plugin.ep.ModImporter](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/test/kotlin/icu/windea/pls/ep/tools/importer/ParadoxModImporterTest.kt:19:0-75:1), `ModExporter`
    - 提供 UI 框架（动作、菜单等）依赖 EP 列表动态构建
    - 无 sqlite-jdbc 依赖
  - 扩展插件（SQLite Support）
    - 依赖主插件
    - 引入 `ktorm` + `sqlite-jdbc`
    - 注册 EP 实现：`ParadoxLauncherDbImporter/Exporter` 等
    - 可独立发布为“附加组件”，用户按需安装

- 优点
  - 物理隔离依赖；Core 完全不带 sqlite 依赖且无需类存在性判断
  - 用户体验更好（插件市场可按需安装扩展）
- 缺点
  - 需要拆分工程与 EP 设计，初始改造量略大

---

### 方案对比与落地优先级

- 快速落地优先：优先采用“方案一（单插件双变体）”
  - 原因：仅需少量构建脚本与运行期能力探测；对现有代码侵入小
- 中长期演进：“方案二（扩展插件）”
  - 原因：彻底解决依赖体积、解耦功能；发布维护灵活

---

### 关键实现点（仅示例片段，不修改文件）

- Gradle 依赖与构建属性（示例，Kotlin DSL）
  ```kotlin
  // gradle.properties
  // includeSqlite=true

  // build.gradle.kts
  val includeSqlite = providers.gradleProperty("includeSqlite").getOrElse("true").toBoolean()

  dependencies {
      implementation("org.ktorm:ktorm-core:<ver>") // 体积较小
      if (includeSqlite) {
          runtimeOnly("org.xerial:sqlite-jdbc:<ver>") // 体积较大，仅 Full 变体打包
      }
      testImplementation("org.xerial:sqlite-jdbc:<ver>") // 测试总是可用
  }

  // 可选：根据变体调整插件版本号后缀，便于在 Marketplace 上区分
  tasks.patchPluginXml {
      val suffix = if (!includeSqlite) "-lite" else ""
      version.set("${project.version}$suffix")
  }

  // 可选：提供两个便捷任务
  tasks.register("buildPluginLite") {
      doFirst { project.extensions.extraProperties["includeSqlite"] = "false" }
      finalizedBy(tasks.named("buildPlugin"))
  }
  tasks.register("buildPluginFull") {
      doFirst { project.extensions.extraProperties["includeSqlite"] = "true" }
      finalizedBy(tasks.named("buildPlugin"))
  }
  ```

- 能力探测与 UI 隐藏（示例）
  ```kotlin
  object ParadoxCapabilities {
      fun hasSqlite(): Boolean = try {
          Class.forName("org.sqlite.JDBC")
          true
      } catch (_: Throwable) {
          false
      }
  }

  // 在 SQLite 导入/导出动作的 update() 中
  override fun update(e: AnActionEvent) {
      e.presentation.isEnabledAndVisible = ParadoxCapabilities.hasSqlite()
  }

  // 在 execute() 的入口处
  if (!ParadoxCapabilities.hasSqlite()) {
      // 例如弹出通知：“当前构建不包含 SQLite 支持”
      return ParadoxModImporter.Result(total = 0, actualTotal = 0)
  }
  ```

---

### 发布与文档建议

- 发布
  - CI 增加矩阵构建 Full/Lite 两个产物；Lite 在版本号或渠道上做区分
  - 若未来拆分为扩展插件，两个插件各自独立版本与变更日志

- 文档
  - 在 `README`/`docs/` 中明确说明：
    - Lite 版不包含 SQLite 功能，相关按钮/菜单会被隐藏
    - 如需使用“导入/导出（SQLite）”请安装 Full 版或额外的“SQLite 支持”扩展插件
  - 在插件内通过“帮助/关于”或“设置”提供当前构建能力的说明（例如是否启用 SQLite）

---

### 总结

- 若希望快速达成目标且不大动工程结构：采用“单插件双变体 + 运行期能力探测 + UI 隐藏”即可满足你的需求，测试依然完备。
- 若希望长期彻底解耦：将 SQLite 能力拆分为独立扩展插件（可与 EP 配合），主插件完全无 SQLite 依赖，用户按需安装扩展。

## PLS 与 IMM 的实现差异，以及目前存在的问题和可优化项


我将先通过 MCP 的 jdbc 工具读取本地 launcher-v2.sqlite 的结构与示例数据，然后在 GitHub 上检索并阅读 IronyModManager 的 Importers/Exporter 相关源码，最后综合对比并给出报告。接下来开始并行执行两类检索。

我将并行执行以下操作：
- 通过 JDBC MCP 工具读取本地 launcher-v2.sqlite 的迁移标记、表结构和示例数据，确认 position 的存储形态。
- 在 GitHub 上获取 IronyModManager 的 Importers/Exporter 相关源码目录与关键文件，检索 position 的生成与解析逻辑。

现在开始并行调用这些工具。





























### 摘要

- 基于本机 launcher-v2.sqlite 的实测：当前数据库版本为 V4+，`playsets_mods.position` 字段为 INTEGER，位置从 0 递增。
- 基于 IronyModManager（IMM）源码核对：V2 的 `playlist.json` 中 `mods[].position` 使用的是“十六进制字符串，固定 10 位，小写，前导 0 填充”，计算方式为 [(index + 1 + 4096).ToString("x10")](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/model/JsonModels.kt:54:4-66:5)。
- PLS（本项目）当前实现与 IMM 有两个关键差异：
  - V2 JSON 导出：PLS 使用“十进制字符串 + 左侧补零 10 位”；IMM 使用“十六进制字符串 + 左侧补零 10 位”。建议统一为十六进制，确保兼容官方启动器与 IMM。
  - V2 JSON 导入排序：PLS 的排序解析方法只考虑十进制字符串；IMM 直接用字符串排序（因 10 位 0 填充，字典序 == 数值序）。建议 PLS 解析时同时兼容十进制和十六进制，或退回到字符串排序。

以下是详细报告和改进建议。

---

### 一、本地 sqlite 快照（通过 MCP：`jdbc_launcher_v2_sqlite`）

- 表结构
  - `playsets_mods` 描述：
    - `position`: INTEGER（本机数据库为 V4+，已从 TEXT 迁移为 INTEGER）
- 迁移标记（`knex_migrations`）
  - 包含 `modifyPositionToInteger`、`addModShortDescription` 等，确认为 V4+ 与 V5 特征
- 示例数据
  - `playsets_mods.position` 多条记录为 0、1、2、…，符合 V4+ 从 0 递增的整数定义
  - [mods.source](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/test/kotlin/icu/windea/pls/ep/tools/model/DataModelsValidationTest.kt:105:4-149:1) 包含 `local`、`steam` 等

结论：
- 本机数据库确认为 V4+；V2/V3 的 TEXT 位置字符串仅在旧库（或 openbeta）里存在。

---

### 二、IMM 在线源码关键信息

- V2 JSON 导出（`src/IronyModManager.IO/Mods/Exporter/ParadoxLauncherExporter.cs`）
  - 生成 position 的代码：
    ```csharp
    private const int Pos = 4096;
    Position = (validMods.IndexOf(p) + 1 + Pos).ToString("x10"),
    ```
  - 结论：十六进制字符串（小写），固定 10 位，左侧 0 填充。
  - 同时排除 [ModSource.Local](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/test/kotlin/icu/windea/pls/test/AssumePredicates.kt:9:4-9:103) 的模组（仅导出 pdx/steam）
- V2 JSON 导入（`src/IronyModManager.IO/Mods/Importers/ParadoxLauncherImporter.cs`）
  - 读取 V2 时，先用长度大于 4 的粗略条件做版本识别，然后：
    - 直接对 `mods.Where(p => p.Enabled).OrderBy(p => p.Position)` 做字符串排序
  - 结论：IMM 不解析十六进制为整数，而是基于 10 位固定长度字符串排序；因 0 填充，字典序==数值序，排序正确

---

### 三、PLS 当前实现核对与差异点

- V2 JSON 导出（[icu.windea.pls.ep.tools.exporter.ParadoxLauncherJsonV2Exporter](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/exporter/ParadoxLauncherJsonV2Exporter.kt:25:0-86:1)）
  - 通过 [ParadoxMetadataManager.formatLauncherPosition(index, isV4Plus=false)](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:196:4-204:5) 生成 position
  - 现实现是十进制字符串 + 左侧补零 10 位
  - 差异：与 IMM 不一致（IMM 为十六进制），建议改为十六进制字符串
  - 已对齐点：同 IMM，排除本地源（Local）模组

- V2 JSON 导入（`icu.windea.pls.ep.tools.importer.ParadoxLauncherJsonImporter` 以及工具方法）
  - 当前 [parseLauncherV2PositionToInt](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:184:4-194:5) 只考虑十进制：`trimStart('0').toIntOrNull()`
  - 风险：当输入为十六进制（带 a-f）时会失败，返回 `Int.MAX_VALUE`，导致排序异常
  - 建议：兼容两种格式
    - 若 `position` 含 a-f 字母 → 按 16 进制解析
    - 否则 → 仍按十进制解析
    - 或退回到“字符串排序”（与 IMM 一致），因固定 10 位 0 填充

- V4+ SQLite 导出（`icu.windea.pls.ep.tools.exporter.ParadoxLauncherDbExporter`）
  - 通过 `knex_migrations` 判断是否 V4+（包含 `modifyPositionToInteger`）
  - V4+：写入 `position = index`（INTEGER，从 0 递增）
  - V2：写入字符串 position（目前用十进制固定 10 位）
  - 建议：若需兼容 V2 DB TEXT 写法，建议与 JSON V2 一致，使用十六进制固定 10 位；但需注意官方老版本 DB 的真实写法是否为十进制或十六进制（IMM 对 DB 的导出逻辑未直接找到源码，谨慎处理，必要时以实机老库采样为准）

- [ParadoxGameJsonExporter](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/exporter/ParadoxGameJsonExporter.kt:25:0-90:1)
  - 已复用 [ParadoxMetadataManager.buildDescriptorMapping](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:206:4-226:5)，并在路径映射失败时回退到 `mod/ugc_{id}.mod`，行为合理

---

### 四、问题与可优化项列表

- 问题（建议尽快修复）
  - V2 JSON 导出的 `position` 编码格式偏差：
    - 现为十进制固定 10 位，IMM 为十六进制固定 10 位
    - 影响：与 IMM 生成的 `playlist.json` 不一致，可能影响官方导入器或第三方工具的兼容性
  - V2 JSON 导入解析：
    - 现仅支持十进制字符串，遇到十六进制（a-f）将排序异常（落到末尾）
    - 影响：导入 IMM 或官方导出的 V2 `playlist.json` 时，顺序可能错误

- 可优化项
  - V2 DB 导出的 TEXT position：如需覆盖老库，建议确认“官方/IMM 历史库里 TEXT 字段的真实格式（十进制或十六进制）”，之后再统一策略
    - 若为十六进制 → 与 V2 JSON 对齐
    - 若为十进制 → 保持十进制，避免破坏向后兼容
  - V2 JSON 导入的版本识别策略：
    - 目前 PLS 使用 JSON Tree 探测 `mods[].position` 类型（很稳妥）
    - IMM 用“长度大于 4”粗判，PLS 方案更优；可保留
  - “能力开关”与“UI 隐藏”：
    - 你已将 `sqlite-jdbc` 改为 `runtimeOnly`（很棒），配合“类存在性检查”隐藏/禁用 SQLite 功能可以进一步完善 Lite 变体体验

---

### 五、建议的修复方案（不复杂，若你同意我可直接修改）

- 修改工具方法 [ParadoxMetadataManager.formatLauncherPosition](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:196:4-204:5)
  - 逻辑：
    - `isV4Plus == true` → `index.toString()`（整数）
    - `isV4Plus == false`（V2）→ [(index + 4096 + 1).toString(16).padStart(10, '0')](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/model/JsonModels.kt:54:4-66:5)
- 修改 [ParadoxMetadataManager.parseLauncherV2PositionToInt](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:184:4-194:5)
  - 逻辑（伪码）：
    ```kotlin
    fun parseLauncherV2PositionToInt(pos: String?): Int {
        if (pos.isNullOrBlank()) return Int.MAX_VALUE
        val s = pos.trim()
        val hasHexLetter = s.any { it in 'a'..'f' || it in 'A'..'F' }
        return if (hasHexLetter) s.trimStart('0').ifEmpty { "0" }.toIntOrNull(16) ?: Int.MAX_VALUE
               else s.trimStart('0').ifEmpty { "0" }.toIntOrNull(10) ?: Int.MAX_VALUE
    }
    ```
  - 或在 V2 导入阶段使用字符串排序（等价且简单），因为 10 位 0 填充保证字典序==数值序
- 修正模型注释与测试数据
  - [JsonModels.kt](cci:7://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/model/JsonModels.kt:0:0-0:0) 中 V2 `position` 注释改回十六进制
  - [src/test/resources/tools/playlist_v2.json](cci:7://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/test/resources/tools/playlist_v2.json:0:0-0:0) 的 `position` 改为十六进制样例（如：`0000001001` 对应 4097 → 0x1001）
  - 调整相应的测试断言：解析后得到 4097、4098、4099

这些改动范围小、风险低，可快速完成并回归。

---

### 六、PLS 与 IMM 在导入/导出逻辑上的差异总结

- 版本检测
  - PLS：通过 JSON 节点类型（V2 为 string，V3 为 int）精准探测；SQLite 通过迁移表判断 V4+/V5
  - IMM：V2 JSON 通过“position 长度大于 4”做粗判；SQLite 同样通过迁移判断
- V2 `position` 生成与排序
  - PLS：当前生成十进制（建议改为十六进制），解析按十进制（建议兼容十六进制或用字符串排序）
  - IMM：生成十六进制、更稳健地通过字符串排序避免数值解析问题
- 源过滤（Local）
  - PLS：导出时排除 Local（与 IMM 一致）
  - IMM：明确只导出 pdx/steam
- JSON（game-data 导出）
  - 双方都支持 `dlc_load.json` / `content_load.json`，PLS 使用 `descriptor.mod.path` 或 `ugc` 回退逻辑合理，IMM 也有类似策略

---

### 七、结论与后续建议

- 结论
  - V2 `playlist.json` 的 `position` 应当使用十六进制 10 位字符串（与 IMM 对齐），这也是社区事实标准。
  - PLS 目前的 V2 导出/导入细节与该事实标准存在偏差，建议尽快修复，以保证与官方启动器及 IMM 的互操作性、避免排序异常。

- 后续建议
  - 若你同意，我可以直接提交一个最小改动 PR：
    - 修改 [formatLauncherPosition](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:196:4-204:5)、[parseLauncherV2PositionToInt](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:184:4-194:5)
    - 调整 V2 测试样例与断言
  - 如需同时兼容“V2 DB TEXT position”的历史格式，请提供一份旧版 [launcher-v2.sqlite](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/test/kotlin/icu/windea/pls/ep/tools/model/DataModelsValidationTest.kt:105:4-149:1) 样例；我将基于样例确定 TEXT 的真实编码（十进制还是十六进制），再给出精确实现。

我参考了你的“去除 sqlite 依赖”的记录与会话笔记，以及之前对“导入/导出器补充中文 KDoc、SQLite 自动化测试均已通过”的记忆，并结合本机数据库与 IMM 源码完成以上核查。需要我现在就落实上述小改动吗？
### 结论速览

- Launcher JSON V2 的 `mods[].position` 在 IronyModManager（IMM）中是“十六进制字符串（小写）+ 左侧补零到 10 位”，计算为 [(index + 4096 + 1).ToString("x10")](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/model/JsonModels.kt:82:4-94:5)。证据来自 `IronyModManager.IO/Mods/Exporter/ParadoxLauncherExporter.cs`。
- 你本机的 [launcher-v2.sqlite](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/test/kotlin/icu/windea/pls/ep/tools/model/DataModelsValidationTest.kt:105:4-149:1) 实测为 V4+ 模式：`playsets_mods.position` 的类型为 INTEGER，且数据为从 0 递增的整数（通过 MCP 工具实时读取确认，`knex_migrations` 含 `modifyPositionToInteger`）。
- PLS 当前的 V2 JSON 导出使用“十进制字符串（10 位补零）”，与 IMM 存在偏差；V2 JSON 导入的排序解析仅按十进制解析，也与 IMM 的做法（按 10 位字符串字典序）存在差异。建议修正为兼容十六进制与字符串排序，导出改为十六进制。

---

### 数据来源与验证方式

- 本地数据库（通过 MCP: `jdbc_launcher_v2_sqlite`）
  - `describe playsets_mods`：`position` 为 `INTEGER`（V4+）
  - `select name from knex_migrations`：包含 `modifyPositionToInteger`（V4 标志）及 `addModShortDescription`（V5 标志）
  - [select playsetId, modId, enabled, position from playsets_mods ...](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/model/JsonModels.kt:82:4-94:5)：position 为 0、1、2… 递增
- IMM 在线源码（GitHub 原始文件）
  - 导出 V2 JSON：
    - `src/IronyModManager.IO/Mods/Exporter/ParadoxLauncherExporter.cs`
      - 关键语句：
        ```csharp
        private const int Pos = 4096;
        Position = (validMods.IndexOf(p) + 1 + Pos).ToString("x10"),
        ```
    - 排除本地源（Local），只导出 Steam/Paradox 源
  - 导入 V2/V3 JSON：
    - `src/IronyModManager.IO/Mods/Importers/ParadoxLauncherImporter.cs`
      - V2：以“position 字符串长度 > 4”粗判，再按 `mods.Where(p => p.Enabled).OrderBy(p => p.Position)` 做字符串排序（10 位补零 => 字典序等价数值序）
  - 备注：IMM 的 DB 导出器源码未直接检索到，但 SQLite 的导入按版本（v2/v4/v5）区分，V4+ 已迁移为 INTEGER

---

### 逐项对比（PLS vs IMM）

- 导出 Launcher JSON V2（[icu.windea.pls.ep.tools.exporter.ParadoxLauncherJsonV2Exporter](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/exporter/ParadoxLauncherJsonV2Exporter.kt:25:0-86:1)）
  - PLS：`position` 由 [ParadoxMetadataManager.formatLauncherPosition(index, false)](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:196:4-204:5) 生成，目前是“十进制字符串（10 位补零）”
  - IMM：`position` 为“十六进制字符串（10 位补零，小写）”
  - 一致点：均排除本地源（Local）模组
  - 建议：改为十六进制 10 位（与 IMM、社区事实标准一致）

- 导入 Launcher JSON V2（`icu.windea.pls.ep.tools.importer.ParadoxLauncherJsonImporter`）
  - PLS：版本探测很精准（看 `mods[].position` 类型），排序解析仅按十进制（[parseLauncherV2PositionToInt](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:184:4-194:5)）
  - IMM：V2 以长度粗判；排序直接字典序（适配 10 位补零十六进制）
  - 风险：当遇到十六进制 position（含 a-f）时，PLS 的十进制解析会失败，排序退化（会落到末尾）
  - 建议：兼容十六进制与十进制两种格式；或在 V2 直接采用字符串排序（与 IMM 一致）

- 导出 Launcher DB（`icu.windea.pls.ep.tools.exporter.ParadoxLauncherDbExporter`）
  - PLS：通过 `knex_migrations` 检测 V4+；V4+ 写入整数 position（从 0 递增）；V2 写入字符串 position（目前为十进制 10 位）
  - IMM：未找到 DB 导出源码细节；但 V4+ 一定是 INTEGER
  - 建议：V4+ 当前实现正确；V2 的 TEXT 写法是否十六进制没有充分样本，维持现状（十进制 10 位）更稳妥。若后续拿到老库样本再决定是否切换为十六进制

- 导出 Game JSON（[icu.windea.pls.ep.tools.exporter.ParadoxGameJsonExporter](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/exporter/ParadoxGameJsonExporter.kt:22:0-86:1)）
  - PLS：使用 [buildDescriptorMapping](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:206:4-226:5) + `remoteId` 回退 `mod/ugc_{id}.mod`，逻辑稳妥
  - IMM：类似策略

- 源过滤
  - PLS/IMM：都排除 Local 源，仅导出 Steam/Paradox

---

### 已发现问题与优先修复项

- 问题（建议尽快修复）
  - Launcher JSON V2 的 `position` 编码偏差
    - PLS：十进制 10 位
    - IMM：十六进制 10 位
    - 影响：与 IMM、官方导出格式不一致，可能导致互导不兼容
  - V2 导入排序解析不兼容十六进制
    - 影响：遇到十六进制 position 时顺序异常

- 可优化项
  - V2 TEXT position（DB）的确切格式
    - 建议保守维持十进制 10 位，待拿到“旧版 V2 DB 样本”后再决定是否调整为十六进制
  - 能力开关与 UI 隐藏
    - 你已将 `sqlite-jdbc` 调整为 `runtimeOnly`，可以配合类存在性检测隐藏基于 SQLite 的导入/导出器（满足 Lite 版）

---

### 建议的修复方案（小改动即可完成）

- 修改工具方法（`icu.windea.pls.lang.util.ParadoxMetadataManager`）
  - [formatLauncherPosition(index, isV4Plus)](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:196:4-204:5)：
    - `isV4Plus == true` → `index.toString()`（整数）
    - `isV4Plus == false` → [(index + 4097).toString(16).padStart(10, '0')](cci:2://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/model/JsonModels.kt:82:4-94:5)（十六进制 10 位，小写）
  - [parseLauncherV2PositionToInt(pos: String?)](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:184:4-194:5)：
    - 若包含 a-f（忽略大小写）→ 按 16 进制解析（去前导 0）
    - 否则 → 按 10 进制解析（去前导 0）
    - 解析失败返回 `Int.MAX_VALUE`
    - 或者：V2 导入阶段直接用字符串排序（10 位补零保障正确性），无需转整数（与 IMM 一致）

- 调整 V2 测试样例与注释
  - [src/test/resources/tools/playlist_v2.json](cci:7://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/test/resources/tools/playlist_v2.json:0:0-0:0)：
    - 将 `position` 修改为十六进制 10 位（如 4097 → 0x1001 → `0000001001`）
  - [JsonModels.kt](cci:7://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/ep/tools/model/JsonModels.kt:0:0-0:0) 中 V2 的注释同步改为十六进制说明
  - `DataModelsValidationTest` 中 V2 的断言同步按十六进制解析或改为字符串排序断言

- Launcher DB 导出
  - 保持 V4+ 写入整数（当前正确）
  - V2（TEXT）暂不改；待有老库样本再决定是否改为十六进制写法

---

### 影响评估

- 与 IMM 的 JSON V2 完全对齐（导入/导出互操作性更好）
- 对 V3/V4+/Game JSON 导入/导出不产生影响
- 对现有 SQLite 导出（V4+）无影响
- 测试改动小，资源型测试可快速回归

---

### 其他建议（与 Lite 版无 SQLite 相关）

- 构建：你已将 `sqlite-jdbc` 改为 `runtimeOnly`，可进一步通过 Gradle 属性（如 `-PincludeSqlite=false`）控制是否打入产物，测试继续使用 `testImplementation`。配合能力探测（`Class.forName("org.sqlite.JDBC")`）在动作 `update()` 隐藏相关功能。
- 文档：在 `README`/`docs` 中标注 V2 的 `position` 为十六进制，避免误解。

---

### 是否需要我直接落地这些“小改动”？

- 若你同意，我可以直接：
  - 更新 [formatLauncherPosition](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:196:4-204:5)、[parseLauncherV2PositionToInt](cci:1://file:///D:/Documents/Projects/__Pinned/Paradox-Language-Support/src/main/kotlin/icu/windea/pls/lang/util/ParadoxMetadataManager.kt:184:4-194:5)
  - 同步修改 V2 的测试样例与注释
  - 回归执行资源型测试（不依赖本地环境），确保通过

请确认是否立即实施。