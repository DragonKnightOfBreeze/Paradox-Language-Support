### 需求（三版）：支持任意深度内联脚本的规则上下文与定义声明

> 在二版的“模板索引 + 查询期联结”基础上，进一步解决“内联脚本可在任意处、任意深度使用”导致的 CWT 规则上下文推断与代码补全、定义声明解析问题。

- **范围**：
  - 允许在内联脚本文件中，基于其所有使用位置（usage）的“挂载点上下文”进行合并推断，在编辑内联脚本文件本身时能得到正确的补全（包括上层 rootKey，如 `spriteTypes` 和 `spriteType`）。
  - 允许内联脚本中直接声明定义（例如 `spriteType` 下的 `name = GFX_xxx`），并在“查询期联结”中正确解析其定义名（含占位符替换）与类型，支持跳转/查找用法。

---

### 现状与根因（关键代码）

- **上下文提供器**：`icu.windea.pls.ep.configContext.CwtConfigContextProvider`
  - `BaseCwtConfigContextProvider`：当元素位于某个定义内部时，`elementPathFromRoot` 相对于定义根计算；否则仅按文件信息提供上下文。
  - `InlineScriptUsageCwtConfigContextProvider`：在“调用处”针对 `inline_script` 之后的子路径提供上下文（可在定义之外）。
  - `InlineScriptCwtConfigContextProvider`：用于“内联脚本文件本身”的上下文推断，已有注释“TODO 支持解析内联脚本文件中的定义声明”。
    - 当前在 `getConfigs` 中，顶层（`elementPathFromRoot` 为空）时通过 `ParadoxInlineScriptManager.getInferredContextConfigs(...)` 合并 usages 的上下文；
    - 但非顶层时依赖 `inlineScriptRootConfigContext = ParadoxExpressionManager.getConfigContext(file)`，这与“基于 usages 合并出的根上下文”不一致，导致多层补全和声明判断不稳定。

- **定义识别与索引**：`icu.windea.pls.lang.util.ParadoxDefinitionManager`
  - `matchesTypeFast` 强依赖“文件路径 + 元素路径 + rootKey 前缀”等；内联脚本文件实际路径为 `common/inline_scripts`，多数类型的 `path` 模式不匹配，因而无法直接按存根策略识别为定义。

- **二版方案局限**
  - 二版通过“模板索引 + 查询期联结”补足了“名称替换与定义解析”，但未彻底解决“在内联脚本文件中进行深层补全/声明判断”的上下文一致性。

---

### 三版目标

- **上下文一致**：在内联脚本文件的任意深度位置，获得与“在其某个调用处被内联展开后”一致的 CWT 规则上下文，从而：
  - 补全可覆盖“上层 rootKey（如 `spriteTypes`）与对应的定义键（如 `spriteType`）”。
  - 允许内联脚本中直接声明的定义在编辑时得到正确的 schema 校验。
- **定义解析**：配合二版的查询期联结，支持从任意处调用的内联脚本中声明的定义（含占位符），实现跳转/查找用法等能力。
- **可扩展与安全降级**：当不同 usages 合并后上下文冲突时，能回退到“尽力补全 + 明确提示冲突”的模式，不阻断基础编辑体验。

---

### 设计要点

- **挂载点（Mount Point）模型**
  - 每个内联脚本的“调用处”都可以看作一个“挂载点”，在该位置将内联脚本文件的内容“拼接”进去。
  - 记为：`Usage.mountPath`（相对于调用处 `inline_script` 的子路径）与 `Usage.rootConfigs`（调用处推断出的根子规则集合）。

- **根上下文聚合（Aggregation）**
  - `InlineScriptCwtConfigContextProvider` 在“顶层”调用 `ParadoxInlineScriptManager.getInferredContextConfigs(...)` 收集“所有 usages 的 rootConfigs”，使用 `CwtConfigManipulator.mergeConfigs(...)` 合并。
  - 对“任意深度”的元素，使用“同一份合并后的 rootConfigs + elementPathFromRoot”调用 `ParadoxExpressionManager.getConfigsForConfigContext(...)` 获得稳定的下钻上下文。
  - 当合并失败（冲突）或递归时，设置 `context.inlineScriptHasConflict/inlineScriptHasRecursion`，并降级策略（见下）。

- **类型与路径的“虚拟投影（Virtual Projection）”**
  - 定义识别不再依赖内联脚本文件的真实 `filePath`。在“查询期联结”时，基于 `Usage` 的 `rootConfigs` 判断某属性是否为某类型的声明（替代 `matchesFilePathPattern` 的约束）。
  - 这样避免在索引期为内联脚本生成“错误路径下的存根”，将类型判断延迟到查询期并绑定实际“使用场景”。

- **补全覆盖上层 rootKey**
  - 顶层（`elementPathFromRoot` 为空）直接以“合并后的 rootConfigs”的键/值规则进行补全，因而可补出 `spriteType` 等键；
  - 若编辑者在内联脚本顶部补 `spriteType = { ... }`，下层根据 `rootConfigs` 中对应的声明规则给出值结构补全与校验。

---

### 方案详情

- **A. 重构 `InlineScriptCwtConfigContextProvider`**
  - `getContext(...)`：保持现状（识别内联脚本文件 + 记录 `inlineScriptExpression` + `elementPathFromRoot`）。
  - `getConfigs(...)`：
    - 当 `elementPathFromRoot.isEmpty()`：使用 `ParadoxInlineScriptManager.getInferredContextConfigs(...)` 获取并缓存“合并的 rootConfigs”（若冲突则打标）。
    - 当 `elementPathFromRoot.isNotEmpty()`：直接基于“合并的 rootConfigs”调用 `ParadoxExpressionManager.getConfigsForConfigContext(...)` 获取下钻规则。
  - 移除对 `inlineScriptRootConfigContext = ParadoxExpressionManager.getConfigContext(file)` 的依赖，避免与 usages 上下文割裂。

- **B. 扩展 `ParadoxInlineScriptManager`（工具层）**
  - `getArgumentMap(property: ParadoxScriptProperty): Map<String, String>`：读取 `inline_script` 调用处除 `script` 外的键值（简单文本）作为参数映射。
  - `getMountPath(property: ParadoxScriptProperty): ParadoxExpressionPath`：返回调用处 `inline_script` 的“父路径相对位移”，用于解释“把内联脚本内容放在调用处的哪个深度”。
  - `aggregateRootConfigs(expression, context, matchOptions)`：遍历 `ParadoxInlineScriptUsageSearch` 的结果，逐个 usage：
    - 取 `usageConfigContext = ParadoxExpressionManager.getConfigContext(memberElement)`，得到 `rootConfigs`；
    - 基于 `CwtConfigManipulator.mergeConfigs(...)` 合并（出现不可合并即打标 `inlineScriptHasConflict`）。
  - 缓存策略：按 `(inlineScriptExpression, matchOptions)` 以及可选“游戏类型/根路径偏移”维度缓存合并结果。

- **C. 查询期联结（与二版衔接）**
  - `InlineResolvedDefinitionSearcher`：
    - 读取“模板索引”（二版新增，记录 `nameExprParts` 与 `nameFieldPath`，`type` 可选）；
    - 遍历 `ParadoxInlineScriptUsageSearch` 的调用点，抽取 `params`，替换得到 `resolvedName`；
    - 基于 `usageConfigContext.getConfigs(...)` 判断该位置的该属性是否对应某 `definitionType`（若模板未存 `type` 或需校验一致性）。
    - 命中后返回模板 PSI 对应的名称文本区间，或定义元素。

- **D. 冲突与降级**
  - 若 rootConfigs 合并冲突：
    - 补全层面采用“并集（去重）”策略，避免报错，但在 UI 提示“上下文冲突，结果可能不准确”。
    - 解析层面对于类型判定严格时可跳过该 usage，以稳定优先（可开启“宽松模式”用于编辑期体验）。

---

### 与二版的关系

- 二版关注“名称模板索引 + 查询期联结”；三版补齐“任何深度的上下文推断与补全一致性”。
- 索引侧仍保持“最小”：不在索引期决定类型归属，类型判断留给“查询期 + usage 上下文”。

---

### 实施步骤（增量）

- **M1.5（上下文重构）**
  - 重构 `InlineScriptCwtConfigContextProvider.getConfigs`，以合并的 rootConfigs 为唯一根。
  - 新增 `ParadoxInlineScriptManager.aggregateRootConfigs`，并对冲突/递归打标。

- **M2（联结增强）**
  - `InlineResolvedDefinitionSearcher` 支持“按 usage 上下文判定类型”，模板索引 `type` 字段可选；
  - 对 `nameFieldPath` 与 `nameExprParts` 做完整替换与转义处理。

- **M3（补全与校验）**
  - 顶层与任意深度补全一致性测试（`spriteTypes/spriteType` 场景）；
  - 冲突回退 UI 与开关。

- **M4（性能与缓存）**
  - 为合并的 rootConfigs 与联结结果建立 LRU 缓存；
  - 大项目基线测试，确保编辑体验稳定。

---

### 测试矩阵

- **语义**：
  - 顶层补全能出现 `spriteType`；其值块内可按 `sprite` 声明规则补全。
  - 使用处在不同挂载点（不同父路径）时，内联脚本文件内补全/校验能反映差异；冲突时降级。
- **解析**：
  - 含占位符名称的定义在查询期可被解析与跳转；
  - 常量名模板与存根结果去重。
- **边界**：
  - 缺参/再次参数化/多行字符串（不考虑内联脚本在多行参数值中使用）；
  - 递归/循环引用；
  - 多游戏类型配置并存。

---

### 风险与回退

- **风险**：多挂载点合并导致规则冲突；查询期联结的性能压力；名称替换的边界复杂（转义/条件块）。
- **回退**：
  - 冲突时并集补全 + 明确提示；
  - 解析时仅在一致或“最相关” usage 上生效；
  - 可通过设置关闭“跨 usage 合并”，退回“仅从最相关 usage 推断”。

---

### 关键改动点列表（供代码评审）

- `InlineScriptCwtConfigContextProvider.getConfigs`：统一由“合并 rootConfigs”驱动。
- `ParadoxInlineScriptManager`：新增 `getArgumentMap`、`getMountPath`、`aggregateRootConfigs`。
- `InlineResolvedDefinitionSearcher`：从 usages 动态判定类型并联结模板。
- `ParadoxExpressionManager`：保持 `getConfigsForConfigContext` 为下钻入口，无需侵入修改。
