# 笔记：问题解决

## 构建

 ### verifyPluginSignature 显示 NO-SOURCE（未找到可校验的签名包）
 
 - **背景**
   - 在 `build.gradle.kts` 中已配置 `intellijPlatform { signing { ... } }`（参见 `~179–183` 行），并在系统中设置了 `CERTIFICATE_CHAIN_PLS`、`PRIVATE_KEY_PLS`、`PRIVATE_KEY_PASSWORD_PLS` 等环境变量。
 - **现象**
   - 执行：
     ```powershell
     .\gradlew verifyPluginSignature -i
     ```
     输出：
     ```
     > Task :verifyPluginSignature NO-SOURCE
     Skipping task ':verifyPluginSignature' as it has no source files and no previous output files.
     ```
 - **排查过程**
   - 检查 `build/distributions` 目录，未见包含 `-signed.zip` 的插件包。
   - 查阅 JetBrains 文档可知：`verifyPluginSignature` 仅“校验”，不会触发签名或构建；若没有已签名 ZIP 作为输入，会被标记为 NO-SOURCE。
 - **结论（根因）**
   - 没有可供校验的输入文件（已签名的插件 ZIP），因此任务被标记为 NO-SOURCE。这与是否重启 IDE/电脑无关。
 - **解决步骤**
   1. 重启 Gradle 守护进程以便读取新的环境变量（可选）：
      ```powershell
      .\gradlew --stop
      ```
   2. 先签名再校验（Wrapper + PowerShell 下注意前缀 `.` 和 `\`）：
      ```powershell
      .\gradlew signPlugin verifyPluginSignature -i
      ```
   3. 验证产物是否生成（应看到 `-signed.zip`）：
      ```powershell
      Get-ChildItem -File .\build\distributions
      ```
 - **注意事项**
   - 优先使用 `.\gradlew`，避免全局 Gradle 带来的环境差异。
   - 当前构建脚本使用环境变量值作为证书链与私钥的“内容”。若提供的是“文件路径”，需改用插件支持的文件式配置方式（否则会解析失败）。
   - 如果终端会话较早启动，可能未继承新的环境变量；用 `.\gradlew --stop` 或新开终端即可，无需重启电脑。
 - **参考链接**
   - JetBrains 插件签名文档：https://plugins.jetbrains.com/docs/intellij/plugin-signing.html

 ### signPlugin 抛出 NPE：PrivateKeyUtils.loadKeyPair（密钥/证书内容格式不正确）
 
 - **背景**
   - 已按 `build.gradle.kts` 中的 `intellijPlatform { signing { ... } }` 进行签名配置：
     - `certificateChain = envVars("CERTIFICATE_CHAIN_PLS")`
     - `privateKey = envVars("PRIVATE_KEY_PLS")`
     - `password = envVars("PRIVATE_KEY_PASSWORD_PLS")`
 - **现象**
   - 执行：
     ```powershell
     .\gradlew signPlugin verifyPluginSignature -i
     ```
   - 失败并抛出 NPE，日志摘录（详见 `notes/ai-notes/logs/sign-verify-latest.log`）：
     ```text
     > Task :signPlugin FAILED
     ... org.jetbrains.zip.signer.ZipSigningTool sign ... -key <long-base64> -cert <long-base64> -key-pass ********
     Exception in thread "main" java.lang.NullPointerException
       at org.jetbrains.zip.signer.signer.PrivateKeyUtils.loadKeyPair(PrivateKeyUtils.kt:62)
     ```
 - **诊断**
   - 从命令行回显可见：`-key` 与 `-cert` 以“单行 Base64”形式传入，缺少 PEM 头尾与换行（如 `-----BEGIN PRIVATE KEY-----`/`-----END PRIVATE KEY-----`、`-----BEGIN CERTIFICATE-----`/`-----END CERTIFICATE-----`）。
   - `marketplace-zip-signer` 解析私钥时未能识别有效内容，最终在 `PrivateKeyUtils.loadKeyPair` 处触发 NPE。
   - 另一个常见踩坑：提供的是 PKCS#1（`BEGIN RSA PRIVATE KEY`）而非 PKCS#8（`BEGIN PRIVATE KEY` 或 `BEGIN ENCRYPTED PRIVATE KEY`）。
 - **结论（根因）**
   - 环境变量中的签名材料内容格式不符合签名工具期望：
     - 丢失 PEM 头尾与换行（仅有 Base64 主体）。
     - 或私钥为 PKCS#1，签名器期望 PKCS#8。
 - **解决步骤**
   1. 准备“正确格式”的 PEM 内容：
      - 私钥：PKCS#8（未加密：`BEGIN PRIVATE KEY`；加密：`BEGIN ENCRYPTED PRIVATE KEY`）。
      - 证书链：一个或多个 `BEGIN CERTIFICATE`/`END CERTIFICATE` 块，按链顺序拼接。
   2. 将 PEM 原样（含头尾与换行）写入环境变量（示例，当前会话）：
      ```powershell
      $env:PRIVATE_KEY_PLS        = Get-Content -Raw -LiteralPath 'D:\secrets\pls\private_key_pkcs8.pem'
      $env:CERTIFICATE_CHAIN_PLS  = Get-Content -Raw -LiteralPath 'D:\secrets\pls\cert_chain.pem'
      $env:PRIVATE_KEY_PASSWORD_PLS = '你的私钥口令'
      ```
      - 若变量里存放的是“转义换行”（如 `\n`），需反转义为真实换行。
   3. 若你的私钥是 PKCS#1，请先转换为 PKCS#8（示例命令，需安装 OpenSSL）：
      - 未加密：
        ```bash
        openssl pkcs8 -topk8 -inform PEM -in private_rsa.pem -out private_pkcs8.pem -nocrypt
        ```
      - 加密：
        ```bash
        openssl pkcs8 -topk8 -inform PEM -in private_rsa.pem -out private_pkcs8.pem -v2 aes-256-cbc \
          -passin pass:原口令 -passout pass:新口令
        ```
   4. 重新执行：
      ```powershell
      .\gradlew --stop
      .\gradlew signPlugin verifyPluginSignature -i
      ```
      - 预期：`build/distributions` 下生成 `*-signed.zip`，随后 `verifyPluginSignature` 正常校验。
 - **注意事项**
   - 不要将密钥/证书文件提交到仓库；建议放在本机安全路径，并通过环境变量注入内容。
   - 若在 CI（如 GitHub Actions）中注入多行 PEM，注意换行保真；必要时可在流水线中将 `\n` 还原为真实换行。
   - 如需提升健壮性，可在 `build.gradle.kts` 中实现“环境变量既可为 PEM 内容，也可为本地文件路径，并自动将 `\n` 还原”的处理逻辑（可按需实施）。
 - **参考链接**
   - JetBrains 插件签名文档：https://plugins.jetbrains.com/docs/intellij/plugin-signing.html
   - marketplace-zip-signer（CLI 实际执行器）：https://github.com/JetBrains/marketplace-zip-signer

### Gradle Download 插件下载失败：SSLHandshakeException / PKIX path building failed

- **[背景]** 在 `build.gradle.kts` 中使用 `de.undercouch.download` 插件，通过 HTTPS 从 GitHub 下载 CWT 规则 zip；本机存在代理/AdGuard 或自签根证书。
- **[现象]** 执行 `downloadCwtConfig_*`（例如 `downloadCwtConfig_ck2`）失败：
  ```
  javax.net.ssl.SSLHandshakeException: PKIX path building failed
  sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
  ```
- **[结论（根因）]** Gradle 守护进程所用 JVM 的信任库未信任代理/拦截软件的根证书，TLS 握手校验失败。
- **[排查要点]**
  - 确认 Gradle 实际使用的 JVM：
    ```powershell
    .\gradlew -version
    ```
  - IDEA 的 JBR 与 Gradle Daemon 可能不同，证书需导入“Gradle 使用的 JVM”。
- **[解决步骤 A·临时兜底]** 仅限受限网络/排障时使用（只影响下载插件的请求）：
  ```powershell
  .\gradlew downloadCwtConfig_ck2 -Ppls.cwt.acceptAnyCertificate=true --stacktrace
  .\gradlew clean buildPlugin -Ppls.cwt.acceptAnyCertificate=true
  ```
- **[解决步骤 B·推荐做法]** 给 Gradle JVM 配置可信根证书：
  1) 找到 `JVM:` 路径（来自 `gradlew -version`）。
  2) 导入根证书到该 JVM 的默认 trustStore：
     ```powershell
     C:\path\to\jdk\bin\keytool.exe -importcert -alias adguard ^
       -file D:\Documents\杂项\证书\cert.cer ^
       -keystore "C:\path\to\jdk\lib\security\cacerts" -storepass changeit
     ```
     或者使用自定义 trustStore，并在构建时指定：
     ```powershell
     .\gradlew downloadCwtConfig_ck2 ^
       -Djavax.net.ssl.trustStore="D:\Documents\杂项\证书\cacerts_adguard" ^
       -Djavax.net.ssl.trustStorePassword=changeit
     ```
  3) 重启 Gradle 守护进程并重试：
     ```powershell
     .\gradlew --stop
     .\gradlew downloadCwtConfig_ck2 --stacktrace
     .\gradlew clean buildPlugin
     ```
- **[注意事项]**
  - 不建议长期开启 `-Ppls.cwt.acceptAnyCertificate=true`；应尽快改为正确的 trustStore 配置。
  - 若启用系统代理/AdGuard，确保其根证书被“Gradle 使用的 JVM”信任。
  - PowerShell 下执行 Gradle 推荐前缀 `.\\gradlew`，路径含空格需加引号。
- **[参考链接]**
  - de.undercouch.download 插件：https://github.com/michel-kraemer/gradle-download-task

## 前端相关（参考文档）

### VuePress docs:dev 启动失败（Vite 7 与 Node 版本不兼容，crypto.hash is not a function）

- **背景**
  - 使用 VuePress 2 搭建文档，`docs/package.json` 主要版本：
    - `vuepress@2.0.0-rc.25`
    - `@vuepress/bundler-vite@2.0.0-rc.25`
    - `vuepress-theme-hope@2.0.0-rc.94`
    - 一些官方插件为 `2.0.0-rc.112`
  - 先前为修复 `TemplateRendererOutlet` 导出错误，已将 VuePress 核心统一到 `rc.25`，并显式使用 `viteBundler()`。

- **现象**
  - 启动开发服务器：
    ```powershell
    pnpm.cmd run docs:dev
    ```
  - 报错（摘要）：
    ```text
    TypeError: crypto.hash is not a function
        at getHash (.../docs/node_modules/.pnpm/vite@7.1.3.../vite/dist/node/chunks/dep-*.js:2649:21)
    ```

- **排查过程**
  - 查看 Vite 产物 `dep-*.js`，`getHash()` 使用 `crypto.hash("sha256", ...)`，你的当前 Node 版本为 `v20.10.0`，并不提供该 API。
  - 查看 `vite@7.1.3` 的 `package.json`：
    - `"engines": { "node": "^20.19.0 || >=22.12.0" }`
    - 结论：需要 Node `>=20.19.0`（或 `>=22.12.0`）。
  - 查看 `@vuepress/bundler-vite@2.0.0-rc.25/package.json`：
    - 依赖 `"vite": "~7.1.3"`，意味着 Bundler 锁定 Vite 7，不宜简单降级 Vite。
  - 运行安装日志存在大量 peer dependency 警告（主题/插件多数声明 `vuepress@2.0.0-rc.24`），但不影响当前报错，属于兼容范围提示。

- **结论**
  - 根因：Node 版本过低（`v20.10.0`），不满足 `vite@7.1.3` 的 engines 要求，导致 `crypto.hash` 不存在，从而在 dev 启动阶段抛错。
  - 方向：升级 Node 到满足要求的版本（推荐 `>=22.12.0`，或至少 `20.19.0`）。

- **解决方案（Windows / nvm）**
  - 使用 nvm（已安装 `1.1.12`）升级并切换 Node：
    ```powershell
    nvm install 22.12.0
    nvm use 22.12.0
    node -v     # 确认版本 ≥ v22.12.0
    pnpm.cmd run docs:dev
    ```
  - 若需最低满足要求：
    ```powershell
    nvm install 20.19.0
    nvm use 20.19.0
    node -v
    pnpm.cmd run docs:dev
    ```

- **补充说明**
  - 目前的 peer 警告（如主题/插件期望 `vuepress@rc.24`，而项目为 `rc.25`）非致命，可暂时忽略；`@vuepress/utils@rc.25` 已包含 `TemplateRendererOutlet`，与主题期望一致。
  - 若后续遇到奇怪缓存，可清理（若存在）`docs/node_modules/.vite` 后重试。
  - 在 PowerShell 上建议使用 `pnpm.cmd` 以绕过执行策略限制。

- **经验教训 / Checklist**
  - 先根据堆栈定位到具体包与实现位置，判断是运行时 API 缺失还是导出不匹配。
  - 检查第三方包的 `engines` 字段与本地运行时（Node）是否匹配。
  - 核对 Bundler/框架是否锁定底层工具版本（例如 `@vuepress/bundler-vite` 锁定 Vite 7）。
  - Windows 终端下注意用 `pnpm.cmd`，避免被执行策略阻挡。

### nvm use 后 node -v 仍输出旧版本（NVM_SYMLINK 非符号链接导致）

- **现象**
  - 执行 `nvm use 22.12.0` 后，`node -v` 仍显示 `v20.10.0`。

- **诊断**
  - `where node` 输出：`D:\Program Files\nodejs\node.exe`。
  - `fsutil reparsepoint query "D:\\Program Files\\nodejs"`：返回“不是重解析点（not a reparse point）”。
  - 环境变量：
    - `NVM_HOME=C:\Users\29442\AppData\Roaming\nvm`（存在 `v22.12.0/` 目录）。
    - `NVM_SYMLINK=D:\Program Files\nodejs`。
    - PATH 同时包含 `C:\Users\29442\AppData\Roaming\nvm` 与 `D:\Program Files\nodejs`，Node 实际解析为后者。

- **根因**
  - `NVM_SYMLINK` 指向的 `D:\Program Files\nodejs` 是一个普通目录而非符号链接/联接目录，导致 nvm 无法通过切换目标来更新 `node.exe` 指向的版本。

- **修复方案（推荐）**
  1) 以管理员权限打开 PowerShell/CMD，关闭占用 Node 的进程（IDE 终端等）。
  2) 备份原目录：
     ```powershell
     ren "D:\Program Files\nodejs" nodejs.bak
     ```
  3) 让 nvm 重建符号链接/联接：
     ```powershell
     nvm use 22.12.0
     ```
  4) 校验：
     ```powershell
     fsutil reparsepoint query "D:\Program Files\nodejs"   # 现在应为重解析点
     where node                                              # 仍是 D:\Program Files\nodejs\node.exe
     node -v                                                 # 预期 v22.12.0
     ```

- **替代方案**
  - 如 nvm 仍无法创建链接，可手动建立目录联接（需管理员）：
    ```cmd
    mklink /J "D:\Program Files\nodejs" "C:\Users\29442\AppData\Roaming\nvm\v22.12.0"
    ```
  - 临时绕过（仅当前会话）：将目标版本目录临时置于 PATH 前缀：
    ```powershell
    $env:Path = "C:\Users\29442\AppData\Roaming\nvm\v22.12.0;" + $env:Path
    node -v
    ```

- **注意事项**
  - 第三方工具（npm/pnpm/yarn）在 `nodejs` 目录下的包装脚本可能被替换为新版本发行包自带的脚本，如需可重新安装或 `corepack enable`。
  - 若遇到“Access is denied”，请确认以管理员身份运行，并排除安全软件阻拦对 `D:\Program Files\nodejs` 的链接写入。

- **验证通过后**
  - 执行：
    ```powershell
    pnpm.cmd run docs:dev
    ```
    预期不再出现 `crypto.hash is not a function` 报错。

### Prism 自定义语法（SSR 扩展，避免 window.Prism 依赖）

- **背景**
  - 文档中的代码块需要自定义高亮：**CWT config file**、Paradox Script、Paradox Localisation、Paradox CSV。
  - VuePress 2 使用 `@vuepress/plugin-prismjs` 在 SSR 阶段完成高亮，不会在浏览器端暴露 `window.Prism`。
  - 结论：不能在 `client.ts` 中通过 `window.Prism` 注册语言，需在 SSR 阶段注册。

- **落地方案**
  - 将自定义 Prism 语言定义拆分为可复用的纯 JS 文件，放置于 `docs/.vuepress/highlighters/`：
    - `prism-cwt.js` → `registerCwt(Prism)`
    - `prism-paradox-script.js` → `registerParadoxScript(Prism)`
    - `prism-paradox-localisation.js` → `registerParadoxLocalisation(Prism)`
    - `prism-paradox-csv.js` → `registerParadoxCsv(Prism)`
    - 以上脚本均支持浏览器直引（检测 `window.Prism` 自动注册），也支持模块化调用。
  - 为每种语言创建 VuePress 插件（SSR 阶段注册语言），放置于 `docs/.vuepress/plugins/`：
    - `prism-cwt-plugin.ts`
    - `prism-paradox-script-plugin.ts`
    - `prism-paradox-localisation-plugin.ts`
    - `prism-paradox-csv-plugin.ts`
    - 插件在其 `extendsMarkdown()` 中执行 `register*(Prism)`，直接修改由 `prismjs` 导入的同一 Prism 实例。
  - 在 `docs/.vuepress/config.ts` 中：
    - **显式启用** `@vuepress/plugin-prismjs`。
    - 注册以上 4 个自定义插件。
  - 在 `docs/.vuepress/client.ts` 中：
    - **移除** 一切对 `window.Prism` 的访问和客户端注册逻辑，仅保留组件注册。

- **语言标识（Markdown 代码块围栏）**
  - 使用以下语言键与定义保持一致：
    - `cwt`
    - `paradox_script`
    - `paradox_localisation`
    - `paradox_csv`
  - 文档中已按以上键编写，匹配无误（`docs/zh/*.md`、`docs/en/*.md`）。

- **目录与关键文件**
  - 语言定义脚本：`docs/.vuepress/highlighters/prism-*.js`
  - VuePress 插件：`docs/.vuepress/plugins/*.ts`
  - 配置：`docs/.vuepress/config.ts`
  - 客户端配置：`docs/.vuepress/client.ts`

- **常见问题与排查**
  - **未生效/无高亮**：检查语言键是否拼写一致；确认插件已在 `config.ts` 的 `plugins` 中启用。
  - **构建时报错找不到语言**：确保在 SSR 插件中已调用相应 `register*(Prism)`；不要依赖 `window.Prism`。
  - **顺序问题**：SSR 渲染前，所有插件的 `extendsMarkdown()` 都会执行；保证已在注册阶段修改了 `Prism.languages`。

- **验证**
  - 执行：
    ```powershell
    pnpm.cmd run docs:build
    ```
  - 预期构建成功，生成页面中 `cwt`、`paradox_script`、`paradox_localisation`、`paradox_csv` 代码块具备高亮。

## 后端相关

### ProfilesSettings 持久化迁移到 SQLite（Ktorm + DbBackedStateMap）（2025-08-31）

- **背景**
  - 先前 `PlsProfilesSettings` 的多个 Map 字段依赖 IntelliJ `BaseState` 的 XML 持久化。为提升可维护性与一致性，迁移到 SQLite。
  - 对外 API 不变，内部以 DB 存储键值（value 为对象的 XML 文本表示）。

- **技术选型**
  - 数据库：SQLite。
  - ORM：Ktorm。
  - XML 编解码：IntelliJ `XmlSerializer` + JDOM（`SAXBuilder`/`XMLOutputter`），封装为 `XmlStateCodec`。

- **核心实现**
  - `icu.windea.pls.lang.settings.tools.ProfilesDatabase`
    - 统一管理 DB 连接；默认路径：`~/.pls/database/profiles.db`（由 `icu.windea.pls.model.constants.PlsPathConstants.database` 确保目录存在）。
  - `icu.windea.pls.lang.settings.tools.DbBackedStateMap<T>`
    - 将 value 通过 `icu.windea.pls.lang.settings.tools.XmlStateCodec` 序列化为紧凑 XML 字符串；
    - `put/putAll` 写入内存缓冲，`flush()` 批量 upsert；
    - `remove/clear` 立即持久化，避免残留键；
    - `get` 惰性反序列化并缓存以优化读取；
    - 修复 `size`：使用 `keys.size` 进行统计。
  - `icu.windea.pls.lang.settings.PlsProfilesSettings`
    - 四个 Map 字段改为 `DbBackedStateMap`，并加 `@get:Transient` 禁用 IDE XML 对这些字段的持久化；
    - 在 `updateSettings()` 中调用 `flush()` 并自增修改计数，明确落盘时机。

- **测试与验证**
  - 集成测试：`icu.windea.pls.lang.settings.PlsProfilesSettingsDbIntegrationTest`
    - 使用临时 SQLite 文件验证嵌套对象 roundtrip、`remove()` 的即时持久化、以及多 Map 并存一致性；
    - 运行命令（PowerShell）：
      ```powershell
      .\gradlew test --tests icu.windea.pls.lang.settings.PlsProfilesSettingsDbIntegrationTest -i --stacktrace --no-configuration-cache
      ```

- **注意事项**
  - 目录初始化依赖 `PlsPathConstants.init()` 触发的异步初始化；IDE 启动后会确保 `~/.pls/database/` 存在；
  - JDOM 相关 API 可能出现弃用告警，但不影响当前功能；如需可后续替换或抑制；
  - 谨慎选择 `flush()` 时机，建议通过统一入口（如 `updateSettings()`）聚合落盘，减少 IO；
  - 在 PowerShell 下执行 Gradle 命令注意前缀：`.\gradlew`。

- **迁移策略（旧 XML -> DB）建议**
  - 插件首次加载时检测历史 XML 数据并批量导入 DB；
  - 迁移完成写入幂等标记（DB meta 表或 `State` 字段），失败进行回滚并打印日志/通知；
  - 迁移流程的测试需覆盖空/部分损坏 XML 场景。

- **参考文件**
  - `src/main/kotlin/icu/windea/pls/lang/settings/tools/ProfilesDatabase.kt`
  - `src/main/kotlin/icu/windea/pls/lang/settings/tools/DbBackedStateMap.kt`
  - `src/main/kotlin/icu/windea/pls/lang/settings/tools/XmlStateCodec.kt`
  - `src/main/kotlin/icu/windea/pls/lang/settings/PlsProfilesSettings.kt`

- **参考命令**
  - 全量测试：
    ```powershell
    .\gradlew test -i --stacktrace --no-configuration-cache
    ```

### 在读操作中使用 withModalProgress 导致可能的死锁（IllegalStateException）

- **背景**
  - 在初始化规则分组时，需要“先刷新规则目录（同步、可取消）再读取解析”。相关代码位于：
    - `src/main/kotlin/icu/windea/pls/ep/configGroup/CwtConfigGroupDataProviders.FileBased.kt` 中 `FileBasedCwtConfigGroupDataProvider.process()`。

- **现象**
  - 调试时抛出：
    ```text
    java.lang.IllegalStateException: Switching to `Dispatchers.EDT` from `runBlockingCancellable` inside in a read-action leads to possible deadlock.
    ```

- **排查过程**
  - `process()` 可能在读锁（read-action）下被调用；
  - 刷新时使用了：
    ```kotlin
    runBlockingCancellable {
        withModalProgress(project, title) {
            rootDirectory.refresh(false, true)
        }
    }
    ```
  - `withModalProgress(...)` 会切到 EDT（`Dispatchers.EDT`），而当前又处于 `runBlockingCancellable` 且在读锁中，平台为避免潜在死锁直接抛出异常。

- **结论（根因）**
  - 在读操作持锁期间，尝试从 `runBlockingCancellable` 切到 EDT（模态进度）是危险的，触发平台的死锁防护。

- **解决方案（已采用）**
  - 改用后台进度，不切到 EDT：
    - 导入：`com.intellij.platform.ide.progress.withBackgroundProgress`
    - 代码：
      ```kotlin
      runBlockingCancellable {
          withBackgroundProgress(configGroup.project, PlsBundle.message("configGroup.refresh.files.progressTitle", configGroup.gameType.id)) {
              fileProvidersAndRootDirectories.forEach { (_, rootDirectory) ->
                  rootDirectory.refresh(false, true) // 同步、递归刷新；后台线程执行
              }
          }
      }
      ```
  - 这保证“可取消 + 刷新完成后再继续”，并避免在读锁内切到 EDT。

- **备选方案**
  - 将“刷新 VFS”的步骤移出读锁：先刷新，后 `runReadAction { ... }` 解析；
  - 使用 `ReadAction.nonBlocking { ... }` 组织后续读取解析，避免长时间持有读锁；
  - 若确需模态进度（UI 阻塞）展示，必须确保当时不在读锁内，再切到 EDT 执行。

- **注意事项**
  - `VirtualFile.refresh(asynchronous = false, recursive = true)` 可在后台线程同步刷新，但不要在 EDT 调用以免卡 UI；
  - 读写锁配合进度与协程时，遵循“在后台线程做重 IO/CPU，UI/EDT 只做轻量操作”的原则；
  - 若上游调用链增加了读锁，需再次审视是否有隐式 EDT 切换的 API（模态对话框、同步 UI 操作等）。

- **参考链接**
  - IntelliJ 平台进度与协程 API（`runBlockingCancellable`/`withBackgroundProgress`）文档与源码注释
  - 相关变更：`CwtConfigGroupDataProviders.FileBased.kt` 将 `withModalProgress` 替换为 `withBackgroundProgress`

### 插件 jar 内置规则文件更新后读取仍为旧内容

- **背景**
  - 插件打包的内置规则文件（位于插件 jar 中 `resources`）在构建后发生更改。
  - 项目重启后通过 `PsiFile.text` 或 `VirtualFile.readText()` 读取仍是旧内容；只有当该文件在编辑器中打开过且再重启，才会读到新内容。

- **现象**
  - 通过 VFS/PSI 获取到的内容与最新构建的 jar 内部文件不一致，呈现“缓存未刷新”的状态。

- **排查过程**
  - 该问题高度符合 IntelliJ 平台 VFS（`JarFileSystem`/`ZipHandler` + PersistentFS）对 jar 条目内容的缓存与失效策略：
    - VFS 根据“外层 jar 的长度/mtime”与“zip entry 的时间戳”决定是否失效缓存；判断“未变”则复用旧内容。
    - Gradle 归档默认启用可复现构建（reproducible archives），可能导致 entry 时间戳被规范化为常量（如 1980-01-01）。若外层 jar 的 mtime/长度也未被有效更新，VFS 误判为未变。
  - 编辑器中打开该文件会触发更积极的刷新路径，从而出现“打开过+重启后才是新内容”的错觉。

- **结论（根因）**
  - Jar VFS 基于 jar/entry 修改戳的缓存未失效，叠加 Gradle 可复现归档导致 entry mtime 恒定，VFS 继续复用旧的 PersistentFS 内容。

- **解决方案**
  - 方案 A（推荐）：绕过 VFS，使用插件 ClassLoader 直接读取资源流。
    ```kotlin
    val loader = this::class.java.classLoader
    val text = loader.getResourceAsStream("rules/your.cwt")
      ?.use { it.readBytes().toString(Charsets.UTF_8) }
      ?: error("resource not found")
    ```
    - 适用于“只读的内置资源”。进程启动时 ClassLoader 指向新 jar，可稳定获取最新内容。
  - 方案 B：在启动时对插件 jar 根做定向 VFS 刷新（保留用 `VirtualFile`/`PsiFile` 的通路）。
    ```kotlin
    import com.intellij.ide.plugins.PluginManagerCore
    import com.intellij.openapi.application.ApplicationManager
    import com.intellij.openapi.extensions.PluginId
    import com.intellij.openapi.vfs.JarFileSystem
    import com.intellij.openapi.vfs.LocalFileSystem
    import com.intellij.openapi.vfs.VfsUtil

    fun refreshPluginJar(pluginId: String, jarName: String) {
        val plugin = PluginManagerCore.getPlugin(PluginId.getId(pluginId)) ?: return
        val jarPath = plugin.pluginPath.resolve("lib").resolve(jarName)
        val local = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(jarPath.toFile()) ?: return
        val jarRoot = JarFileSystem.getInstance().getJarRootForLocalFile(local) ?: return
        ApplicationManager.getApplication().invokeAndWait {
            VfsUtil.markDirtyAndRefresh(true, true, true, jarRoot)
        }
    }
    ```
    - 可在 `projectOpened`/`StartupActivity` 中调用；刷新范围仅限插件自身 jar，避免全局 IO 压力。
  - 方案 C：从构建源头修复可复现归档对 mtime 的影响，使 VFS 能正确判变。
    ```kotlin
    // build.gradle.kts
    import org.gradle.api.tasks.bundling.AbstractArchiveTask

    tasks.withType<AbstractArchiveTask>().configureEach {
        isPreserveFileTimestamps = true        // 允许 entry 使用真实时间戳
        // isReproducibleFileOrder = false     // 如需，可视情况关闭稳定排序
    }
    ```
    - 同时建议调试期清理/替换 IDE 沙箱中的插件目录或提升插件版本号，确保新 jar 被复制。
  - 方案 D（兜底，不建议长期使用）：全局 VFS 刷新
    ```kotlin
    com.intellij.openapi.vfs.VirtualFileManager.getInstance().asyncRefresh(null)
    ```

- **注意事项**
  - 若必须依赖 PSI/VFS 能力（索引、引用等），建议“用 ClassLoader 读取文本 → 如需 PSI，再用该文本生成临时 PSI/或在定向刷新后访问 `VirtualFile`”。
  - 刷新不要在 EDT 做重 IO；如在读锁（read-action）上下文中，避免切到模态进度 EDT，可用后台进度执行刷新。
  - Windows 下本地调试时，注意 PowerShell 执行 Gradle 用 `./gradlew` 前缀（`.\gradlew`）。

- **参考链接**
  - IntelliJ Virtual File System 概述：https://plugins.jetbrains.com/docs/intellij/virtual-file-system.html
  - Gradle 可复现归档与时间戳选项：
    - https://docs.gradle.org/current/userguide/working_with_files.html#sec:reproducible_archives
    - `AbstractArchiveTask.isPreserveFileTimestamps`/`isReproducibleFileOrder`

### 何时优先使用 fastutil 中的集合

基于 README.md 描述的能力与使用流程（多语言 PSI 解析、全局搜索/导航、规则系统、索引阶段“等待 IDE 完成索引”等），可以推断插件在真实使用中存在大量“读多写少”的数据处理与跨文件全局查询。结合这些运行特征，优先考虑使用 fastutil 集合的典型场景如下。

### 何时优先使用 fastutil

- **高基数、内存敏感的数据结构**
  - 特征：需要同时维护大量元素（本地化键、定义名、文件路径、规则项等），并长期驻留内存。
  - 理由：fastutil 的开放地址哈希与原生类型专用容器（如 Int2Object、ObjectOpenHashSet）在大规模数据上更省内存、速度更稳定。

- **热路径中的高频增查操作**
  - 特征：搜索/导航过程中对片段、符号、标识符进行“去重 + contains/add”的紧密循环。
  - 理由：在热点循环里，fastutil 通常提供更低的分配和更快的哈希路径，有利于降低 CPU 时间。

- **可将键压缩为原始类型的映射/集合**
  - 特征：能将字符串键离线映射为 int/id，再在运行时频繁访问。
  - 理由：fastutil 的原始类型容器（如 IntSet/Int2ObjectMap）避免装箱，减少 GC 压力。

- **单线程（或线程受限）构建、随后只读发布**
  - 特征：索引/预处理阶段在单线程或受控线程内构建大型 Map/Set，构建完成后在查询阶段只读访问。
  - 理由：fastutil 在非并发写入、只读访问的模式下优势明显。

### 何时不建议使用 fastutil（或需谨慎）

- **并发回调/并行检索的写入路径**
  - 特征：IDE 在索引/搜索时会并发触发回调（README 中的“等待索引完成”“全局搜索”等可推断并行处理存在）。
  - 风险：fastutil 的大多数集合并非线程安全，并发写入可能触发重哈希问题。
  - 做法：并发写入场景优先用 JDK 并发集合（如 `ConcurrentHashMap.newKeySet()`）、或在线程本地收集后合并。

- **数据规模与访问频率都不高**
  - 特征：集合元素上限较小、访问频率低，或以可读性为主。
  - 做法：保持标准集合，减少依赖与心智负担。

- **需要与 Kotlin/JDK 生态广泛互操作**
  - 特征：需要使用流式 API、不可变集合、序列化或与第三方库广泛对接。
  - 做法：标准集合在生态互操作性上更顺滑。

### 决策清单（基于 README 的使用特征）

- **数据量是否“很大”且长期常驻？** 是 → 考虑 fastutil。
- **是否在热路径里频繁 contains/add？** 是 → 考虑 fastutil。
- **是否并发写入？** 是 → 用 JDK 并发集合或先本地收集后合并，避免直接用 fastutil 写入。
- **键是否可降维为原始类型（int/long 等）？** 是 → 优先 fastutil 原生容器。
- **是否需要高互操作性/可读性优先？** 是 → 标准集合更合适。

### 总结

- **适用 fastutil**：大规模、内存敏感、热点增查、构建后只读的集合/映射。
- **避免或谨慎**：任何并发写入路径（优先 JDK 并发集合），以及小规模或生态互操作性要求高的场景。

## 测试

### Gradle + JUnit4 测试无法读取 -D 系统属性

- **背景**
  - 在命令行通过 Gradle 执行 JUnit4 测试时传入 `-Dkey=value`，期望在测试代码中通过 `System.getProperty("key")` 读取。
  - 项目中在 `build.gradle.kts` 里对 `tasks.withType<Test>` 做了自定义，仅设置了若干固定的 `systemProperty`，并未把命令行 `-D` 自动转发到测试 JVM。
- **现象**
  - 测试代码中 `System.getProperty("key")` 得到 `null`；或误用 `System.getenv("key")` 也读取不到。
- **排查过程**
  - 检查 `build.gradle.kts` 中的 `tasks.withType<Test> { ... }` 配置，发现只对 `pls.is.debug` 等固定键设值；`doFirst { systemProperties.filter { it.key.startsWith("pls.test.") } ... }` 读取的是 Test 任务自身属性，无法感知 Gradle 进程上的命令行 `-D`。
  - 确认差异：`-D` 为 JVM 系统属性，需用 `System.getProperty()`；环境变量应使用 `System.getenv()`，两者互不相通。
  - 在 IDE 里直接用 JUnit 运行器执行测试不会继承 Gradle 命令行的 `-D`；需“Delegate test execution to Gradle”或在运行配置里手动填写 VM Options。
  - Windows PowerShell 下需用 `\.\gradlew` 并对包含空格/反斜杠的值加引号。
- **结论（根因）**
  - 命令行 `-D` 仅作用于 Gradle 守护进程，未被转发到测试 JVM；现有脚本也未从 `System.getProperties()` 把指定前缀的属性注入到 Test 任务。
  - 部分场景还存在“把系统属性当作环境变量读取”的误用。
- **解决方案**
  - 方案 A（按前缀批量转发，推荐）
    ```kotlin
    // build.gradle.kts
    tasks.withType<Test>().configureEach {
        useJUnit()
        // 保留你已有的固定属性
        systemProperty("ide.slow.operations.assertion", "false")
        systemProperty("idea.log.debug.categories", "icu.windea.pls")
        systemProperty("pls.is.debug", "true")
        // 将命令行传入、以 pls.test. 开头的 -D 属性转发到测试 JVM
        val sys = System.getProperties()
        sys.stringPropertyNames()
            .filter { it.startsWith("pls.test.") }
            .forEach { k -> systemProperty(k, sys.getProperty(k)) }
    }
    ```
    - 调用示例：
      ```powershell
      .\gradlew test "-Dpls.test.foo=bar"
      ```
  - 方案 B（白名单键精确转发）
    ```kotlin
    tasks.withType<Test>().configureEach {
        useJUnit()
        listOf("key", "another.key").forEach { k ->
            System.getProperty(k)?.let { systemProperty(k, it) }
        }
    }
    ```
  - 方案 C（改用 Gradle 项目属性 `-P`）
    ```kotlin
    tasks.withType<Test>().configureEach {
        useJUnit()
        project.findProperty("key")?.let { systemProperty("key", it.toString()) }
    }
    ```
    - 调用：`\.\gradlew test -Pkey=value`
  - 方案 D（IDE）
    - 在 Run/Debug 配置的 VM Options 中填写 `-Dkey=value`，或勾选“Delegate to Gradle”。
- **验证**
  ```powershell
  .\gradlew test --tests icu.windea.pls.SomeTest "-Dpls.test.foo=bar" -i --stacktrace
  ```
  ```kotlin
  // 在测试中
  assertEquals("bar", System.getProperty("pls.test.foo"))
  ```
- **注意事项**
  - 使用 `System.getProperty` 读取 `-D`，不要误用 `System.getenv`。
  - PowerShell 下执行 Gradle 建议前缀 `\.\`；带空格/特殊字符的值请加引号。