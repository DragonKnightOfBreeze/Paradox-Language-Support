# 数字签名 学习笔记

## 概述

- **数字签名（Digital Signature）**用于证明消息/文件的完整性与来源真实性，并提供不可否认性。
- 基本思路：对消息做哈希，再用私钥对哈希值进行签名；验签方用对应的公钥验证签名与消息是否匹配。

## 核心概念

- **哈希函数（Hash）**：将任意长度数据映射为固定长度摘要，常见 `SHA-256/384/512`。
- **非对称密钥对**：私钥（签名/解密，需保密）与公钥（验签/加密，可公开）。
- **证书（X.509）与证书链**：证书中包含主体的公钥；证书链将主体证书与中间/根CA连接，建立信任。
- **PEM/DER**：密钥与证书常见编码格式。PEM 为 Base64 文本（有 `-----BEGIN ...-----` 头尾与换行），DER 为二进制。
- **PKCS#1 vs PKCS#8（私钥容器）**：
  - PKCS#1：`BEGIN RSA PRIVATE KEY`（仅RSA）
  - PKCS#8：`BEGIN PRIVATE KEY` 或 `BEGIN ENCRYPTED PRIVATE KEY`（通用，推荐）

## 基本流程

- **签名（Sender）**
  1. 计算消息 `hash = Hash(message)`。
  2. 用私钥对 `hash` 做签名，得到 `signature`。
  3. 将 `message` 与 `signature` 一并发送（可附带证书/证书链）。

- **验证（Receiver）**
  1. 根据附带的证书提取发送方公钥，并验证证书链可信。
  2. 计算 `hash' = Hash(message)`。
  3. 用公钥验证 `signature` 是否对 `hash'` 成立。

- **为什么流程里“看不到公钥”？**
  - 公钥通常包含在发送方的**证书**里，而证书（或证书链）会被一并附加到签名产物中。工具在验证时从证书中取出公钥，而不是要求你单独提供一个“公钥变量”。
  - 在 JetBrains 插件签名中：`signPlugin` 需要私钥+证书链；`verifyPluginSignature` 会读取签名内嵌的证书链，提取公钥并完成验签与链路校验。因此你不会显式传入“公钥”。

## 常见算法与填充

- **RSA**：`RSA-PKCS#1 v1.5`（传统）与 `RSA-PSS`（更推荐）。
- **椭圆曲线（ECDSA）**：签名短、性能好。
- 哈希选择：`SHA-256` 足够常用；更高强度可用 `SHA-384/512`。

## 与 JetBrains 插件签名的映射

- `build.gradle.kts`（intellij-platform-gradle-plugin）配置：
  - `signing.certificateChain`: X.509 证书链（包含公钥）
  - `signing.privateKey`: 私钥（建议 PKCS#8，PEM 文本，含头尾与换行）
  - `signing.password`: 私钥口令（如为加密私钥）
- `signPlugin`：对 `build/distributions/*.zip` 进行签名，并将证书链打包进签名结构中。
- `verifyPluginSignature`：从签名中提取证书链/公钥进行验证，无需单独提供公钥。

## 代码示例（Java，演示签名与验证）

```java
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.*;
import java.util.Base64;

public class SignDemo {
    public static void main(String[] args) throws Exception {
        // 生成临时密钥对（演示用）
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(2048);
        KeyPair kp = kpg.generateKeyPair();

        byte[] data = "hello-sign".getBytes(StandardCharsets.UTF_8);

        // 签名（SHA256withRSA）
        Signature signer = Signature.getInstance("SHA256withRSA");
        signer.initSign(kp.getPrivate());
        signer.update(data);
        byte[] sig = signer.sign();
        System.out.println("signature=" + Base64.getEncoder().encodeToString(sig));

        // 验证
        Signature verifier = Signature.getInstance("SHA256withRSA");
        verifier.initVerify(kp.getPublic());
        verifier.update(data);
        System.out.println("verify=" + verifier.verify(sig));
    }
}
```

## Kotlin 示例（JDK 21）

- 以下示例均为最小可用代码，便于快速验证。生产环境请结合“密钥管理与安全实践”。

### RSA-PSS（SHA-256, MGF1, saltLen=32）

```kotlin
import java.security.KeyPairGenerator
import java.security.Signature
import java.security.spec.MGF1ParameterSpec
import java.security.spec.PSSParameterSpec
import java.util.Base64

fun rsaPssDemo() {
    val kpg = KeyPairGenerator.getInstance("RSA")
    kpg.initialize(2048)
    val kp = kpg.generateKeyPair()
    val data = "hello-rsa-pss".toByteArray()

    val pss = PSSParameterSpec("SHA-256", "MGF1", MGF1ParameterSpec.SHA256, 32, 1)

    val signer = Signature.getInstance("RSASSA-PSS")
    signer.setParameter(pss)
    signer.initSign(kp.private)
    signer.update(data)
    val sig = signer.sign()
    println("RSA-PSS sig=" + Base64.getEncoder().encodeToString(sig))

    val verifier = Signature.getInstance("RSASSA-PSS")
    verifier.setParameter(pss)
    verifier.initVerify(kp.public)
    verifier.update(data)
    println("RSA-PSS verify=" + verifier.verify(sig))
}
```

### ECDSA（P-256, SHA256withECDSA）

```kotlin
import java.security.KeyPairGenerator
import java.security.Signature
import java.security.spec.ECGenParameterSpec
import java.util.Base64

fun ecdsaP256Demo() {
    val kpg = KeyPairGenerator.getInstance("EC")
    kpg.initialize(ECGenParameterSpec("secp256r1")) // P-256
    val kp = kpg.generateKeyPair()
    val data = "hello-ecdsa".toByteArray()

    val signer = Signature.getInstance("SHA256withECDSA")
    signer.initSign(kp.private)
    signer.update(data)
    val sig = signer.sign()
    println("ECDSA sig=" + Base64.getEncoder().encodeToString(sig))

    val verifier = Signature.getInstance("SHA256withECDSA")
    verifier.initVerify(kp.public)
    verifier.update(data)
    println("ECDSA verify=" + verifier.verify(sig))
}
```

### Ed25519（EdDSA）

```kotlin
import java.security.KeyPairGenerator
import java.security.Signature
import java.util.Base64

fun ed25519Demo() {
    val kpg = KeyPairGenerator.getInstance("Ed25519")
    val kp = kpg.generateKeyPair()
    val data = "hello-ed25519".toByteArray()

    val signer = Signature.getInstance("Ed25519")
    signer.initSign(kp.private)
    signer.update(data) // Ed25519 建议一次性提供完整消息；本例仅调用一次 update
    val sig = signer.sign()
    println("Ed25519 sig=" + Base64.getEncoder().encodeToString(sig))

    val verifier = Signature.getInstance("Ed25519")
    verifier.initVerify(kp.public)
    verifier.update(data)
    println("Ed25519 verify=" + verifier.verify(sig))
}
```

### 证书链验证（Kotlin / JDK 21，简化示例）

- 假设已获取根证书 `rootCaPem` 与从叶子到中间的 `chain`（PEM 解码后的 DER 字节序列），关闭吊销检查用于演示。

```kotlin
import java.io.ByteArrayInputStream
import java.security.cert.CertPathValidator
import java.security.cert.CertificateFactory
import java.security.cert.PKIXParameters
import java.security.cert.TrustAnchor
import java.security.cert.X509Certificate

fun validateWithRoot(rootCaDer: ByteArray, chainDer: List<ByteArray>) {
    val cf = CertificateFactory.getInstance("X.509")
    val certs = chainDer.map { der ->
        cf.generateCertificate(ByteArrayInputStream(der)) as X509Certificate
    }
    val certPath = cf.generateCertPath(certs) // 顺序：叶子 -> 中间...

    val root = cf.generateCertificate(ByteArrayInputStream(rootCaDer)) as X509Certificate
    val params = PKIXParameters(setOf(TrustAnchor(root, null))).apply {
        isRevocationEnabled = false // 演示：未启用 CRL/OCSP
    }
    val validator = CertPathValidator.getInstance("PKIX")
    val result = validator.validate(certPath, params)
    println("CertPath validated: $result")
}
```

### Kotlin 示例（PEM 加载与使用，JDK 21）

```kotlin
import java.security.KeyFactory
import java.security.PrivateKey
import java.security.PublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate
import java.util.Base64

// 解析 PKCS#8 私钥（PEM：BEGIN PRIVATE KEY）
fun loadPrivateKeyPkcs8Pem(pem: String, algorithm: String): PrivateKey {
    val der = decodePemBlock(pem, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----")
    val kf = KeyFactory.getInstance(algorithm) // "RSA" | "EC" | "Ed25519"
    return kf.generatePrivate(PKCS8EncodedKeySpec(der))
}

// 从证书 PEM 中读取公钥（X.509）
fun loadPublicKeyFromCertPem(pem: String): PublicKey {
    val cf = CertificateFactory.getInstance("X.509")
    val cert = cf.generateCertificate(pem.byteInputStream()) as X509Certificate
    return cert.publicKey
}

// 读取证书链（多个 CERTIFICATE 连续放置）
fun loadCertChainPem(pemChain: String): List<X509Certificate> {
    val cf = CertificateFactory.getInstance("X.509")
    return cf.generateCertificates(pemChain.byteInputStream()).map { it as X509Certificate }
}

private fun decodePemBlock(pem: String, header: String, footer: String): ByteArray {
    val start = pem.indexOf(header)
    val end = pem.indexOf(footer)
    require(start >= 0 && end > start) { "PEM block not found: $header" }
    val base64 = pem.substring(start + header.length, end)
        .lines()
        .filter { it.isNotBlank() && !it.startsWith("-----") }
        .joinToString("")
    return Base64.getMimeDecoder().decode(base64)
}
```

### ECDSA P1363 编码（与 DER 编码区别）

```kotlin
import java.security.KeyPairGenerator
import java.security.Signature
import java.security.spec.ECGenParameterSpec

fun ecdsaP1363Demo() {
    val kpg = KeyPairGenerator.getInstance("EC")
    kpg.initialize(ECGenParameterSpec("secp256r1"))
    val kp = kpg.generateKeyPair()
    val data = "hello-ecdsa-p1363".toByteArray()

    val signer = Signature.getInstance("SHA256withECDSAinP1363Format")
    signer.initSign(kp.private)
    signer.update(data)
    val sigP1363 = signer.sign() // r||s 拼接，长度固定（P-256 为 64 字节）

    val verifier = Signature.getInstance("SHA256withECDSAinP1363Format")
    verifier.initVerify(kp.public)
    verifier.update(data)
    println("ECDSA P1363 verify=" + verifier.verify(sigP1363))
}
```

### 文件签名片段（读取/写入）

```kotlin
import java.nio.file.Files
import java.nio.file.Path
import java.security.Signature
import java.util.Base64

fun signFileRsaPss(privateKeyPem: String, file: Path): String {
    val priv = loadPrivateKeyPkcs8Pem(privateKeyPem, "RSA")
    val data = Files.readAllBytes(file)
    val sig = Signature.getInstance("RSASSA-PSS").apply {
        initSign(priv)
        update(data)
    }.sign()
    return Base64.getEncoder().encodeToString(sig)
}
```

## OpenSSL 常见命令

- 生成 RSA 私钥（PKCS#1）与自签证书（演示）：
```bash
# 生成 RSA 私钥（PKCS#1）
openssl genrsa -out private_rsa.pem 2048
# 转 PKCS#8（未加密）
openssl pkcs8 -topk8 -inform PEM -in private_rsa.pem -out private_pkcs8.pem -nocrypt
# 生成自签证书（仅演示，不用于生产）
openssl req -x509 -new -key private_pkcs8.pem -out cert.pem -days 365 -subj "/CN=Demo"
```

- 使用私钥签名文件并验证（演示）：
```bash
# 签名（生成 signature.bin）
openssl dgst -sha256 -sign private_pkcs8.pem -out signature.bin message.txt
# 导出公钥
openssl pkey -in private_pkcs8.pem -pubout -out public.pem
# 验证
openssl dgst -sha256 -verify public.pem -signature signature.bin message.txt
```

## 常见问题与排查

- **PEM 格式**：必须保留头尾与换行。把 PEM 压成单行 Base64 会导致解析失败（常见 NPE/格式错误）。
- **PKCS#1 vs PKCS#8**：很多工具更偏好 PKCS#8。若是 `BEGIN RSA PRIVATE KEY`，先转换为 PKCS#8。
- **口令与算法匹配**：加密私钥需提供正确口令；选择与工具支持匹配的签名算法（如 RSA-PSS vs PKCS#1 v1.5）。
- **字符集与换行**：签名基于字节序列，注意一致的编码与换行（Windows CRLF vs Unix LF）。
- **环境变量注入**：CI/终端中注入多行 PEM 要保真换行；如存储为 "\n" 需在运行时还原成真实换行。

## 与本项目的实践要点

- `signPlugin` 只需要私钥与证书链（证书链里已含公钥）；`verifyPluginSignature` 会从签名中提取证书进行验证。
- 私钥建议使用 **PKCS#8 + PEM**，并通过环境变量以文本形式注入（保留头尾与换行）。

## 算法选择与权衡（RSA / ECDSA / Ed25519）
 - **RSA**：兼容性最好；签名较长；推荐使用 `RSA-PSS`；常见算法标识 `SHA256withRSA`（v1.5）或 `RSASSA-PSS`。
 - **ECDSA（如 P-256/P-384）**：签名短、性能好；需确保高质量随机数或使用 RFC 6979 确定性 nonce；广泛受 JCA 支持。
 - **Ed25519（EdDSA）**：简洁、固定参数、签名短；JDK 15+ 原生支持，老版本可用 BouncyCastle；企业 PKI 与工具链支持需提前确认。
 - **快速建议**：如需最大兼容选 RSA；优先追求性能与体积选 ECDSA/Ed25519；结合生态与合规要求决策。

## 签名容器与常见标准
 - **CMS/PKCS#7（RFC 5652）**：通用签名容器，支持嵌入证书、签名者信息与可选时间戳。
 - **JAR 签名（jarsigner）**：基于 manifest + 签名文件的结构；常用于 Java 生态。
 - **APK 签名（v1/v2/v3/v4）**：Android 专用方案，v2+ 为基于 APK 内容的块级签名。
 - **Authenticode**：Windows PE 可执行文件签名。
 - **PGP/OpenPGP**：邮件/文件签名，常见 `.asc` 分离签名。
 - **JWS/JWT（RFC 7515）** 与 **COSE（RFC 9052）**：JSON/CBOR 对象签名。
 - **Zip/容器级签名**：如 JetBrains marketplace-zip-signer 对插件 zip 进行签名并内嵌证书链。

## 证书链验证与吊销检查
 - **信任锚与路径构建**：从叶子证书到根 CA 的路径验证；依赖系统/应用 TrustStore。
 - **KeyUsage / EKU**：检查证书用途（如代码签名 EKU：1.3.6.1.5.5.7.3.3）。
 - **CRL / OCSP（RFC 6960）**：检查证书是否被吊销；网络可达性与缓存策略影响验证结果（软/硬失败策略）。

## 时间戳与长期验证（LTV）
 - **时间戳（RFC 3161 TSA）**：对签名添加带可信时间源的“见证”，证书过期后仍可证明签名时点有效。
 - **生态支持差异**：是否集成 TSA/计时服务取决于具体签名生态与工具链，请以官方文档为准。

## 确定性签名与随机性
 - **ECDSA nonce**：建议采用 RFC 6979 确定性 nonce，避免低熵随机导致私钥泄漏。
 - **RSA-PSS**：包含随机 salt；必须使用安全随机源（CSPRNG）。
 - **RNG**：确保 JVM 与系统具备高质量熵源（容器/CI 环境尤需关注）。

## 密钥管理与安全实践
 - **生成与强度**：RSA ≥ 2048；椭圆曲线使用主流曲线（P-256 / P-384 / Ed25519）。
 - **存储**：加密私钥（口令妥善管理）；优先 HSM/YubiKey/KMS 等硬件或托管方案。
 - **最小权限与分离**：发布仅授予签名必要权限；限制可访问密钥的主体与环境。
 - **轮换与撤销**：制定密钥轮换、吊销与应急预案；确保存档与审计。
 - **避免泄露**：密钥不入仓；CI 变量最小可见范围；日志绝不回显秘密。

## CI/CD 多行 PEM 注入实践（示例）
 - GitHub Actions（bash）：
   ```yaml
   name: Sign
   on: [push]
   jobs:
     sign:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
         - name: Prepare secrets as files
           run: |
             printf "%s" "${{ secrets.CERTIFICATE_CHAIN }}" > $RUNNER_TEMP/cert_chain.pem
             printf "%s" "${{ secrets.PRIVATE_KEY }}" > $RUNNER_TEMP/private_key.pem
         - name: Run signing
           run: |
             CERTIFICATE_CHAIN_PLS="$(cat $RUNNER_TEMP/cert_chain.pem)" \
             PRIVATE_KEY_PLS="$(cat $RUNNER_TEMP/private_key.pem)" \
             PRIVATE_KEY_PASSWORD_PLS="${{ secrets.PRIVATE_KEY_PASSWORD }}" \
             ./gradlew signPlugin verifyPluginSignature -i
   ```
 - GitHub Actions（pwsh）：
   ```yaml
   - name: Run signing (pwsh)
     shell: pwsh
     run: |
       $env:CERTIFICATE_CHAIN_PLS    = Get-Content -Raw $env:RUNNER_TEMP\cert_chain.pem
       $env:PRIVATE_KEY_PLS          = Get-Content -Raw $env:RUNNER_TEMP\private_key.pem
       $env:PRIVATE_KEY_PASSWORD_PLS = "${{ secrets.PRIVATE_KEY_PASSWORD }}"
       .\gradlew signPlugin verifyPluginSignature -i
   ```

## 常见陷阱清单（扩展）
 - 将 PEM 压成单行 Base64（丢头尾/换行）→ 解析失败。
 - 使用 PKCS#1 私钥但工具期望 PKCS#8。
  - Windows CRLF 与 Unix LF 混用；文件含 BOM；YAML/脚本转义错误。
  - 在日志/错误信息中泄露私钥或证书内容。
  - CI 环境变量长度/转义限制导致内容截断或转义未还原。

## 可扩展内容（可按需扩展）
 - **算法与实现**：RSA-PSS 参数调优、ECDSA 随机性与 RFC 6979、Ed25519/Ed448 对比、性能基准与曲线选择。
 - **证书与 PKI**：证书链构建策略、KeyUsage/EKU 实践、CRL/OCSP/OCSP Stapling、CT 日志、证书透明度与审计。
 - **时间戳与 LTV**：TSA 选型、签名时间与证书有效期关系、长期验证资料的存档策略。
 - **容器与格式**：CMS/PKCS#7、JAR/APK/Authenticode/PGP/JWS/COSE/zip 各容器的签名与验签流程差异。
 - **JCA/JCE 生态**：SunEC/SunRsaSign/BouncyCastle/Conscrypt 等 Provider 的差异与兼容性。
 - **密钥管理**：Java KeyStore（JKS/PKCS12）与 HSM/KMS 集成、密钥轮换/备份/销毁、最小权限与职责分离。
 - **CI/CD 落地**：多行 PEM 注入、秘密管理、缓存与权限边界、跨平台换行一致性与编码策略。
 - **安全与合规**：威胁建模、供应链安全（SLSA、Sigstore/cosign、in-toto 证明）、政策合规与审计证据。
 - **跨语言与互操作**：与 OpenSSL、Node.js、Go、Python、Rust 的签名/验签互认与测试向量。
 - **工程化与调试**：失败模式与错误码、日志与敏感信息保护、离线验签、信任锚与证书固定（pinning）。

## 参考链接
 - CMS/PKCS#7（RFC 5652）：https://datatracker.ietf.org/doc/html/rfc5652
 - 时间戳（RFC 3161）：https://datatracker.ietf.org/doc/html/rfc3161
 - OCSP（RFC 6960）：https://datatracker.ietf.org/doc/html/rfc6960
 - ECDSA 确定性签名（RFC 6979）：https://datatracker.ietf.org/doc/html/rfc6979
 - Ed25519（RFC 8032）：https://datatracker.ietf.org/doc/html/rfc8032
 - JWS（RFC 7515）：https://datatracker.ietf.org/doc/html/rfc7515
 - COSE（RFC 9052）：https://datatracker.ietf.org/doc/html/rfc9052
 - PKCS#8（RFC 5958）：https://datatracker.ietf.org/doc/html/rfc5958
 - jarsigner 文档：https://docs.oracle.com/en/java/javase/17/docs/specs/man/jarsigner.html
 - Android APK Signature Scheme：https://source.android.com/docs/security/features/apksigning
 
 - JetBrains 插件签名：https://plugins.jetbrains.com/docs/intellij/plugin-signing.html
 - marketplace-zip-signer：https://github.com/JetBrains/marketplace-zip-signer
 - X.509（RFC 5280）：https://datatracker.ietf.org/doc/html/rfc5280
 - RSA（RFC 8017）：https://datatracker.ietf.org/doc/html/rfc8017
 - FIPS 180-4（SHA）：https://csrc.nist.gov/publications/detail/fips/180/4/final
 - Java 加密架构（JCA/JCE）概览：https://docs.oracle.com/javase/8/docs/technotes/guides/security/overview/jsoverview.html
