# 数字签名 学习笔记

## 概述

- **数字签名（Digital Signature）**用于证明消息/文件的完整性与来源真实性，并提供不可否认性。
- 基本思路：对消息做哈希，再用私钥对哈希值进行签名；验签方用对应的公钥验证签名与消息是否匹配。

## 核心概念

- **哈希函数（Hash）**：将任意长度数据映射为固定长度摘要，常见 `SHA-256/384/512`。
- **非对称密钥对**：私钥（签名/解密，需保密）与公钥（验签/加密，可公开）。
- **证书（X.509）与证书链**：证书中包含主体的公钥；证书链将主体证书与中间/根CA连接，建立信任。
- **PEM/DER**：密钥与证书常见编码格式。PEM 为 Base64 文本（有 `-----BEGIN ...-----` 头尾与换行），DER 为二进制。
- **PKCS#1 vs PKCS#8（私钥容器）**：
  - PKCS#1：`BEGIN RSA PRIVATE KEY`（仅RSA）
  - PKCS#8：`BEGIN PRIVATE KEY` 或 `BEGIN ENCRYPTED PRIVATE KEY`（通用，推荐）

## 基本流程

- **签名（Sender）**
  1. 计算消息 `hash = Hash(message)`。
  2. 用私钥对 `hash` 做签名，得到 `signature`。
  3. 将 `message` 与 `signature` 一并发送（可附带证书/证书链）。

- **验证（Receiver）**
  1. 根据附带的证书提取发送方公钥，并验证证书链可信。
  2. 计算 `hash' = Hash(message)`。
  3. 用公钥验证 `signature` 是否对 `hash'` 成立。

- **为什么流程里“看不到公钥”？**
  - 公钥通常包含在发送方的**证书**里，而证书（或证书链）会被一并附加到签名产物中。工具在验证时从证书中取出公钥，而不是要求你单独提供一个“公钥变量”。
  - 在 JetBrains 插件签名中：`signPlugin` 需要私钥+证书链；`verifyPluginSignature` 会读取签名内嵌的证书链，提取公钥并完成验签与链路校验。因此你不会显式传入“公钥”。

## 常见算法与填充

- **RSA**：`RSA-PKCS#1 v1.5`（传统）与 `RSA-PSS`（更推荐）。
- **椭圆曲线（ECDSA）**：签名短、性能好。
- 哈希选择：`SHA-256` 足够常用；更高强度可用 `SHA-384/512`。

## 与 JetBrains 插件签名的映射

- `build.gradle.kts`（intellij-platform-gradle-plugin）配置：
  - `signing.certificateChain`: X.509 证书链（包含公钥）
  - `signing.privateKey`: 私钥（建议 PKCS#8，PEM 文本，含头尾与换行）
  - `signing.password`: 私钥口令（如为加密私钥）
- `signPlugin`：对 `build/distributions/*.zip` 进行签名，并将证书链打包进签名结构中。
- `verifyPluginSignature`：从签名中提取证书链/公钥进行验证，无需单独提供公钥。

## 代码示例（Java，演示签名与验证）

```java
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.*;
import java.util.Base64;

public class SignDemo {
    public static void main(String[] args) throws Exception {
        // 生成临时密钥对（演示用）
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(2048);
        KeyPair kp = kpg.generateKeyPair();

        byte[] data = "hello-sign".getBytes(StandardCharsets.UTF_8);

        // 签名（SHA256withRSA）
        Signature signer = Signature.getInstance("SHA256withRSA");
        signer.initSign(kp.getPrivate());
        signer.update(data);
        byte[] sig = signer.sign();
        System.out.println("signature=" + Base64.getEncoder().encodeToString(sig));

        // 验证
        Signature verifier = Signature.getInstance("SHA256withRSA");
        verifier.initVerify(kp.getPublic());
        verifier.update(data);
        System.out.println("verify=" + verifier.verify(sig));
    }
}
```

## OpenSSL 常见命令

- 生成 RSA 私钥（PKCS#1）与自签证书（演示）：
```bash
# 生成 RSA 私钥（PKCS#1）
openssl genrsa -out private_rsa.pem 2048
# 转 PKCS#8（未加密）
openssl pkcs8 -topk8 -inform PEM -in private_rsa.pem -out private_pkcs8.pem -nocrypt
# 生成自签证书（仅演示，不用于生产）
openssl req -x509 -new -key private_pkcs8.pem -out cert.pem -days 365 -subj "/CN=Demo"
```

- 使用私钥签名文件并验证（演示）：
```bash
# 签名（生成 signature.bin）
openssl dgst -sha256 -sign private_pkcs8.pem -out signature.bin message.txt
# 导出公钥
openssl pkey -in private_pkcs8.pem -pubout -out public.pem
# 验证
openssl dgst -sha256 -verify public.pem -signature signature.bin message.txt
```

## 常见问题与排查

- **PEM 格式**：必须保留头尾与换行。把 PEM 压成单行 Base64 会导致解析失败（常见 NPE/格式错误）。
- **PKCS#1 vs PKCS#8**：很多工具更偏好 PKCS#8。若是 `BEGIN RSA PRIVATE KEY`，先转换为 PKCS#8。
- **口令与算法匹配**：加密私钥需提供正确口令；选择与工具支持匹配的签名算法（如 RSA-PSS vs PKCS#1 v1.5）。
- **字符集与换行**：签名基于字节序列，注意一致的编码与换行（Windows CRLF vs Unix LF）。
- **环境变量注入**：CI/终端中注入多行 PEM 要保真换行；如存储为 "\n" 需在运行时还原成真实换行。

## 与本项目的实践要点

- `signPlugin` 只需要私钥与证书链（证书链里已含公钥）；`verifyPluginSignature` 会从签名中提取证书进行验证。
- 私钥建议使用 **PKCS#8 + PEM**，并通过环境变量以文本形式注入（保留头尾与换行）。

## 参考链接

- JetBrains 插件签名：https://plugins.jetbrains.com/docs/intellij/plugin-signing.html
- marketplace-zip-signer：https://github.com/JetBrains/marketplace-zip-signer
- X.509（RFC 5280）：https://datatracker.ietf.org/doc/html/rfc5280
- RSA（RFC 8017）：https://datatracker.ietf.org/doc/html/rfc8017
- FIPS 180-4（SHA）：https://csrc.nist.gov/publications/detail/fips/180/4/final
- Java 加密架构（JCA/JCE）概览：https://docs.oracle.com/javase/8/docs/technotes/guides/security/overview/jsoverview.html
