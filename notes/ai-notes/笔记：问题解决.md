# 笔记：问题解决

## 构建

 ### verifyPluginSignature 显示 NO-SOURCE（未找到可校验的签名包）
 
 - **背景**
   - 在 `build.gradle.kts` 中已配置 `intellijPlatform { signing { ... } }`（参见 `~179–183` 行），并在系统中设置了 `CERTIFICATE_CHAIN_PLS`、`PRIVATE_KEY_PLS`、`PRIVATE_KEY_PASSWORD_PLS` 等环境变量。
 - **现象**
   - 执行：
     ```powershell
     .\gradlew verifyPluginSignature -i
     ```
     输出：
     ```
     > Task :verifyPluginSignature NO-SOURCE
     Skipping task ':verifyPluginSignature' as it has no source files and no previous output files.
     ```
 - **排查过程**
   - 检查 `build/distributions` 目录，未见包含 `-signed.zip` 的插件包。
   - 查阅 JetBrains 文档可知：`verifyPluginSignature` 仅“校验”，不会触发签名或构建；若没有已签名 ZIP 作为输入，会被标记为 NO-SOURCE。
 - **结论（根因）**
   - 没有可供校验的输入文件（已签名的插件 ZIP），因此任务被标记为 NO-SOURCE。这与是否重启 IDE/电脑无关。
 - **解决步骤**
   1. 重启 Gradle 守护进程以便读取新的环境变量（可选）：
      ```powershell
      .\gradlew --stop
      ```
   2. 先签名再校验（Wrapper + PowerShell 下注意前缀 `.` 和 `\`）：
      ```powershell
      .\gradlew signPlugin verifyPluginSignature -i
      ```
   3. 验证产物是否生成（应看到 `-signed.zip`）：
      ```powershell
      Get-ChildItem -File .\build\distributions
      ```
 - **注意事项**
   - 优先使用 `.\gradlew`，避免全局 Gradle 带来的环境差异。
   - 当前构建脚本使用环境变量值作为证书链与私钥的“内容”。若提供的是“文件路径”，需改用插件支持的文件式配置方式（否则会解析失败）。
   - 如果终端会话较早启动，可能未继承新的环境变量；用 `.\gradlew --stop` 或新开终端即可，无需重启电脑。
 - **参考链接**
   - JetBrains 插件签名文档：https://plugins.jetbrains.com/docs/intellij/plugin-signing.html

 ### signPlugin 抛出 NPE：PrivateKeyUtils.loadKeyPair（密钥/证书内容格式不正确）
 
 - **背景**
   - 已按 `build.gradle.kts` 中的 `intellijPlatform { signing { ... } }` 进行签名配置：
     - `certificateChain = envVars("CERTIFICATE_CHAIN_PLS")`
     - `privateKey = envVars("PRIVATE_KEY_PLS")`
     - `password = envVars("PRIVATE_KEY_PASSWORD_PLS")`
 - **现象**
   - 执行：
     ```powershell
     .\gradlew signPlugin verifyPluginSignature -i
     ```
   - 失败并抛出 NPE，日志摘录（详见 `notes/ai-notes/logs/sign-verify-latest.log`）：
     ```text
     > Task :signPlugin FAILED
     ... org.jetbrains.zip.signer.ZipSigningTool sign ... -key <long-base64> -cert <long-base64> -key-pass ********
     Exception in thread "main" java.lang.NullPointerException
       at org.jetbrains.zip.signer.signer.PrivateKeyUtils.loadKeyPair(PrivateKeyUtils.kt:62)
     ```
 - **诊断**
   - 从命令行回显可见：`-key` 与 `-cert` 以“单行 Base64”形式传入，缺少 PEM 头尾与换行（如 `-----BEGIN PRIVATE KEY-----`/`-----END PRIVATE KEY-----`、`-----BEGIN CERTIFICATE-----`/`-----END CERTIFICATE-----`）。
   - `marketplace-zip-signer` 解析私钥时未能识别有效内容，最终在 `PrivateKeyUtils.loadKeyPair` 处触发 NPE。
   - 另一个常见踩坑：提供的是 PKCS#1（`BEGIN RSA PRIVATE KEY`）而非 PKCS#8（`BEGIN PRIVATE KEY` 或 `BEGIN ENCRYPTED PRIVATE KEY`）。
 - **结论（根因）**
   - 环境变量中的签名材料内容格式不符合签名工具期望：
     - 丢失 PEM 头尾与换行（仅有 Base64 主体）。
     - 或私钥为 PKCS#1，签名器期望 PKCS#8。
 - **解决步骤**
   1. 准备“正确格式”的 PEM 内容：
      - 私钥：PKCS#8（未加密：`BEGIN PRIVATE KEY`；加密：`BEGIN ENCRYPTED PRIVATE KEY`）。
      - 证书链：一个或多个 `BEGIN CERTIFICATE`/`END CERTIFICATE` 块，按链顺序拼接。
   2. 将 PEM 原样（含头尾与换行）写入环境变量（示例，当前会话）：
      ```powershell
      $env:PRIVATE_KEY_PLS        = Get-Content -Raw -LiteralPath 'D:\secrets\pls\private_key_pkcs8.pem'
      $env:CERTIFICATE_CHAIN_PLS  = Get-Content -Raw -LiteralPath 'D:\secrets\pls\cert_chain.pem'
      $env:PRIVATE_KEY_PASSWORD_PLS = '你的私钥口令'
      ```
      - 若变量里存放的是“转义换行”（如 `\n`），需反转义为真实换行。
   3. 若你的私钥是 PKCS#1，请先转换为 PKCS#8（示例命令，需安装 OpenSSL）：
      - 未加密：
        ```bash
        openssl pkcs8 -topk8 -inform PEM -in private_rsa.pem -out private_pkcs8.pem -nocrypt
        ```
      - 加密：
        ```bash
        openssl pkcs8 -topk8 -inform PEM -in private_rsa.pem -out private_pkcs8.pem -v2 aes-256-cbc \
          -passin pass:原口令 -passout pass:新口令
        ```
   4. 重新执行：
      ```powershell
      .\gradlew --stop
      .\gradlew signPlugin verifyPluginSignature -i
      ```
      - 预期：`build/distributions` 下生成 `*-signed.zip`，随后 `verifyPluginSignature` 正常校验。
 - **注意事项**
   - 不要将密钥/证书文件提交到仓库；建议放在本机安全路径，并通过环境变量注入内容。
   - 若在 CI（如 GitHub Actions）中注入多行 PEM，注意换行保真；必要时可在流水线中将 `\n` 还原为真实换行。
   - 如需提升健壮性，可在 `build.gradle.kts` 中实现“环境变量既可为 PEM 内容，也可为本地文件路径，并自动将 `\n` 还原”的处理逻辑（可按需实施）。
 - **参考链接**
   - JetBrains 插件签名文档：https://plugins.jetbrains.com/docs/intellij/plugin-signing.html
   - marketplace-zip-signer（CLI 实际执行器）：https://github.com/JetBrains/marketplace-zip-signer

## 前端相关（参考文档）

### VuePress docs:dev 启动失败（Vite 7 与 Node 版本不兼容，crypto.hash is not a function）

- **背景**
  - 使用 VuePress 2 搭建文档，`docs/package.json` 主要版本：
    - `vuepress@2.0.0-rc.25`
    - `@vuepress/bundler-vite@2.0.0-rc.25`
    - `vuepress-theme-hope@2.0.0-rc.94`
    - 一些官方插件为 `2.0.0-rc.112`
  - 先前为修复 `TemplateRendererOutlet` 导出错误，已将 VuePress 核心统一到 `rc.25`，并显式使用 `viteBundler()`。

- **现象**
  - 启动开发服务器：
    ```powershell
    pnpm.cmd run docs:dev
    ```
  - 报错（摘要）：
    ```text
    TypeError: crypto.hash is not a function
        at getHash (.../docs/node_modules/.pnpm/vite@7.1.3.../vite/dist/node/chunks/dep-*.js:2649:21)
    ```

- **排查过程**
  - 查看 Vite 产物 `dep-*.js`，`getHash()` 使用 `crypto.hash("sha256", ...)`，你的当前 Node 版本为 `v20.10.0`，并不提供该 API。
  - 查看 `vite@7.1.3` 的 `package.json`：
    - `"engines": { "node": "^20.19.0 || >=22.12.0" }`
    - 结论：需要 Node `>=20.19.0`（或 `>=22.12.0`）。
  - 查看 `@vuepress/bundler-vite@2.0.0-rc.25/package.json`：
    - 依赖 `"vite": "~7.1.3"`，意味着 Bundler 锁定 Vite 7，不宜简单降级 Vite。
  - 运行安装日志存在大量 peer dependency 警告（主题/插件多数声明 `vuepress@2.0.0-rc.24`），但不影响当前报错，属于兼容范围提示。

- **结论**
  - 根因：Node 版本过低（`v20.10.0`），不满足 `vite@7.1.3` 的 engines 要求，导致 `crypto.hash` 不存在，从而在 dev 启动阶段抛错。
  - 方向：升级 Node 到满足要求的版本（推荐 `>=22.12.0`，或至少 `20.19.0`）。

- **解决方案（Windows / nvm）**
  - 使用 nvm（已安装 `1.1.12`）升级并切换 Node：
    ```powershell
    nvm install 22.12.0
    nvm use 22.12.0
    node -v     # 确认版本 ≥ v22.12.0
    pnpm.cmd run docs:dev
    ```
  - 若需最低满足要求：
    ```powershell
    nvm install 20.19.0
    nvm use 20.19.0
    node -v
    pnpm.cmd run docs:dev
    ```

- **补充说明**
  - 目前的 peer 警告（如主题/插件期望 `vuepress@rc.24`，而项目为 `rc.25`）非致命，可暂时忽略；`@vuepress/utils@rc.25` 已包含 `TemplateRendererOutlet`，与主题期望一致。
  - 若后续遇到奇怪缓存，可清理（若存在）`docs/node_modules/.vite` 后重试。
  - 在 PowerShell 上建议使用 `pnpm.cmd` 以绕过执行策略限制。

- **经验教训 / Checklist**
  - 先根据堆栈定位到具体包与实现位置，判断是运行时 API 缺失还是导出不匹配。
  - 检查第三方包的 `engines` 字段与本地运行时（Node）是否匹配。
  - 核对 Bundler/框架是否锁定底层工具版本（例如 `@vuepress/bundler-vite` 锁定 Vite 7）。
  - Windows 终端下注意用 `pnpm.cmd`，避免被执行策略阻挡。

### nvm use 后 node -v 仍输出旧版本（NVM_SYMLINK 非符号链接导致）

- **现象**
  - 执行 `nvm use 22.12.0` 后，`node -v` 仍显示 `v20.10.0`。

- **诊断**
  - `where node` 输出：`D:\Program Files\nodejs\node.exe`。
  - `fsutil reparsepoint query "D:\\Program Files\\nodejs"`：返回“不是重解析点（not a reparse point）”。
  - 环境变量：
    - `NVM_HOME=C:\Users\29442\AppData\Roaming\nvm`（存在 `v22.12.0/` 目录）。
    - `NVM_SYMLINK=D:\Program Files\nodejs`。
    - PATH 同时包含 `C:\Users\29442\AppData\Roaming\nvm` 与 `D:\Program Files\nodejs`，Node 实际解析为后者。

- **根因**
  - `NVM_SYMLINK` 指向的 `D:\Program Files\nodejs` 是一个普通目录而非符号链接/联接目录，导致 nvm 无法通过切换目标来更新 `node.exe` 指向的版本。

- **修复方案（推荐）**
  1) 以管理员权限打开 PowerShell/CMD，关闭占用 Node 的进程（IDE 终端等）。
  2) 备份原目录：
     ```powershell
     ren "D:\Program Files\nodejs" nodejs.bak
     ```
  3) 让 nvm 重建符号链接/联接：
     ```powershell
     nvm use 22.12.0
     ```
  4) 校验：
     ```powershell
     fsutil reparsepoint query "D:\Program Files\nodejs"   # 现在应为重解析点
     where node                                              # 仍是 D:\Program Files\nodejs\node.exe
     node -v                                                 # 预期 v22.12.0
     ```

- **替代方案**
  - 如 nvm 仍无法创建链接，可手动建立目录联接（需管理员）：
    ```cmd
    mklink /J "D:\Program Files\nodejs" "C:\Users\29442\AppData\Roaming\nvm\v22.12.0"
    ```
  - 临时绕过（仅当前会话）：将目标版本目录临时置于 PATH 前缀：
    ```powershell
    $env:Path = "C:\Users\29442\AppData\Roaming\nvm\v22.12.0;" + $env:Path
    node -v
    ```

- **注意事项**
  - 第三方工具（npm/pnpm/yarn）在 `nodejs` 目录下的包装脚本可能被替换为新版本发行包自带的脚本，如需可重新安装或 `corepack enable`。
  - 若遇到“Access is denied”，请确认以管理员身份运行，并排除安全软件阻拦对 `D:\Program Files\nodejs` 的链接写入。

- **验证通过后**
  - 执行：
    ```powershell
    pnpm.cmd run docs:dev
    ```
    预期不再出现 `crypto.hash is not a function` 报错。

### Prism 自定义语法（SSR 扩展，避免 window.Prism 依赖）

- **背景**
  - 文档中的代码块需要自定义高亮：**CWT config file**、Paradox Script、Paradox Localisation、Paradox CSV。
  - VuePress 2 使用 `@vuepress/plugin-prismjs` 在 SSR 阶段完成高亮，不会在浏览器端暴露 `window.Prism`。
  - 结论：不能在 `client.ts` 中通过 `window.Prism` 注册语言，需在 SSR 阶段注册。

- **落地方案**
  - 将自定义 Prism 语言定义拆分为可复用的纯 JS 文件，放置于 `docs/.vuepress/highlighters/`：
    - `prism-cwt.js` → `registerCwt(Prism)`
    - `prism-paradox-script.js` → `registerParadoxScript(Prism)`
    - `prism-paradox-localisation.js` → `registerParadoxLocalisation(Prism)`
    - `prism-paradox-csv.js` → `registerParadoxCsv(Prism)`
    - 以上脚本均支持浏览器直引（检测 `window.Prism` 自动注册），也支持模块化调用。
  - 为每种语言创建 VuePress 插件（SSR 阶段注册语言），放置于 `docs/.vuepress/plugins/`：
    - `prism-cwt-plugin.ts`
    - `prism-paradox-script-plugin.ts`
    - `prism-paradox-localisation-plugin.ts`
    - `prism-paradox-csv-plugin.ts`
    - 插件在其 `extendsMarkdown()` 中执行 `register*(Prism)`，直接修改由 `prismjs` 导入的同一 Prism 实例。
  - 在 `docs/.vuepress/config.ts` 中：
    - **显式启用** `@vuepress/plugin-prismjs`。
    - 注册以上 4 个自定义插件。
  - 在 `docs/.vuepress/client.ts` 中：
    - **移除** 一切对 `window.Prism` 的访问和客户端注册逻辑，仅保留组件注册。

- **语言标识（Markdown 代码块围栏）**
  - 使用以下语言键与定义保持一致：
    - `cwt`
    - `paradox_script`
    - `paradox_localisation`
    - `paradox_csv`
  - 文档中已按以上键编写，匹配无误（`docs/zh/*.md`、`docs/en/*.md`）。

- **目录与关键文件**
  - 语言定义脚本：`docs/.vuepress/highlighters/prism-*.js`
  - VuePress 插件：`docs/.vuepress/plugins/*.ts`
  - 配置：`docs/.vuepress/config.ts`
  - 客户端配置：`docs/.vuepress/client.ts`

- **常见问题与排查**
  - **未生效/无高亮**：检查语言键是否拼写一致；确认插件已在 `config.ts` 的 `plugins` 中启用。
  - **构建时报错找不到语言**：确保在 SSR 插件中已调用相应 `register*(Prism)`；不要依赖 `window.Prism`。
  - **顺序问题**：SSR 渲染前，所有插件的 `extendsMarkdown()` 都会执行；保证已在注册阶段修改了 `Prism.languages`。

- **验证**
  - 执行：
    ```powershell
    pnpm.cmd run docs:build
    ```
  - 预期构建成功，生成页面中 `cwt`、`paradox_script`、`paradox_localisation`、`paradox_csv` 代码块具备高亮。


## 后端相关

### ProfilesSettings 持久化迁移到 SQLite（Ktorm + DbBackedStateMap）（2025-08-31）

- **背景**
  - 先前 `PlsProfilesSettings` 的多个 Map 字段依赖 IntelliJ `BaseState` 的 XML 持久化。为提升可维护性与一致性，迁移到 SQLite。
  - 对外 API 不变，内部以 DB 存储键值（value 为对象的 XML 文本表示）。

- **技术选型**
  - 数据库：SQLite。
  - ORM：Ktorm。
  - XML 编解码：IntelliJ `XmlSerializer` + JDOM（`SAXBuilder`/`XMLOutputter`），封装为 `XmlStateCodec`。

- **核心实现**
  - `icu.windea.pls.lang.settings.tools.ProfilesDatabase`
    - 统一管理 DB 连接；默认路径：`~/.pls/database/profiles.db`（由 `icu.windea.pls.model.constants.PlsPathConstants.database` 确保目录存在）。
  - `icu.windea.pls.lang.settings.tools.DbBackedStateMap<T>`
    - 将 value 通过 `icu.windea.pls.lang.settings.tools.XmlStateCodec` 序列化为紧凑 XML 字符串；
    - `put/putAll` 写入内存缓冲，`flush()` 批量 upsert；
    - `remove/clear` 立即持久化，避免残留键；
    - `get` 惰性反序列化并缓存以优化读取；
    - 修复 `size`：使用 `keys.size` 进行统计。
  - `icu.windea.pls.lang.settings.PlsProfilesSettings`
    - 四个 Map 字段改为 `DbBackedStateMap`，并加 `@get:Transient` 禁用 IDE XML 对这些字段的持久化；
    - 在 `updateSettings()` 中调用 `flush()` 并自增修改计数，明确落盘时机。

- **测试与验证**
  - 集成测试：`icu.windea.pls.lang.settings.PlsProfilesSettingsDbIntegrationTest`
    - 使用临时 SQLite 文件验证嵌套对象 roundtrip、`remove()` 的即时持久化、以及多 Map 并存一致性；
    - 运行命令（PowerShell）：
      ```powershell
      .\gradlew test --tests icu.windea.pls.lang.settings.PlsProfilesSettingsDbIntegrationTest -i --stacktrace --no-configuration-cache
      ```

- **注意事项**
  - 目录初始化依赖 `PlsPathConstants.init()` 触发的异步初始化；IDE 启动后会确保 `~/.pls/database/` 存在；
  - JDOM 相关 API 可能出现弃用告警，但不影响当前功能；如需可后续替换或抑制；
  - 谨慎选择 `flush()` 时机，建议通过统一入口（如 `updateSettings()`）聚合落盘，减少 IO；
  - 在 PowerShell 下执行 Gradle 命令注意前缀：`.\gradlew`。

- **迁移策略（旧 XML -> DB）建议**
  - 插件首次加载时检测历史 XML 数据并批量导入 DB；
  - 迁移完成写入幂等标记（DB meta 表或 `State` 字段），失败进行回滚并打印日志/通知；
  - 迁移流程的测试需覆盖空/部分损坏 XML 场景。

- **参考文件**
  - `src/main/kotlin/icu/windea/pls/lang/settings/tools/ProfilesDatabase.kt`
  - `src/main/kotlin/icu/windea/pls/lang/settings/tools/DbBackedStateMap.kt`
  - `src/main/kotlin/icu/windea/pls/lang/settings/tools/XmlStateCodec.kt`
  - `src/main/kotlin/icu/windea/pls/lang/settings/PlsProfilesSettings.kt`

- **参考命令**
  - 全量测试：
    ```powershell
    .\gradlew test -i --stacktrace --no-configuration-cache
    ```

### 在读操作中使用 withModalProgress 导致可能的死锁（IllegalStateException）

- **背景**
  - 在初始化规则分组时，需要“先刷新规则目录（同步、可取消）再读取解析”。相关代码位于：
    - `src/main/kotlin/icu/windea/pls/ep/configGroup/CwtConfigGroupDataProviders.FileBased.kt` 中 `FileBasedCwtConfigGroupDataProvider.process()`。

- **现象**
  - 调试时抛出：
    ```text
    java.lang.IllegalStateException: Switching to `Dispatchers.EDT` from `runBlockingCancellable` inside in a read-action leads to possible deadlock.
    ```

- **排查过程**
  - `process()` 可能在读锁（read-action）下被调用；
  - 刷新时使用了：
    ```kotlin
    runBlockingCancellable {
        withModalProgress(project, title) {
            rootDirectory.refresh(false, true)
        }
    }
    ```
  - `withModalProgress(...)` 会切到 EDT（`Dispatchers.EDT`），而当前又处于 `runBlockingCancellable` 且在读锁中，平台为避免潜在死锁直接抛出异常。

- **结论（根因）**
  - 在读操作持锁期间，尝试从 `runBlockingCancellable` 切到 EDT（模态进度）是危险的，触发平台的死锁防护。

- **解决方案（已采用）**
  - 改用后台进度，不切到 EDT：
    - 导入：`com.intellij.platform.ide.progress.withBackgroundProgress`
    - 代码：
      ```kotlin
      runBlockingCancellable {
          withBackgroundProgress(configGroup.project, PlsBundle.message("configGroup.refresh.files.progressTitle", configGroup.gameType.id)) {
              fileProvidersAndRootDirectories.forEach { (_, rootDirectory) ->
                  rootDirectory.refresh(false, true) // 同步、递归刷新；后台线程执行
              }
          }
      }
      ```
  - 这保证“可取消 + 刷新完成后再继续”，并避免在读锁内切到 EDT。

- **备选方案**
  - 将“刷新 VFS”的步骤移出读锁：先刷新，后 `runReadAction { ... }` 解析；
  - 使用 `ReadAction.nonBlocking { ... }` 组织后续读取解析，避免长时间持有读锁；
  - 若确需模态进度（UI 阻塞）展示，必须确保当时不在读锁内，再切到 EDT 执行。

- **注意事项**
  - `VirtualFile.refresh(asynchronous = false, recursive = true)` 可在后台线程同步刷新，但不要在 EDT 调用以免卡 UI；
  - 读写锁配合进度与协程时，遵循“在后台线程做重 IO/CPU，UI/EDT 只做轻量操作”的原则；
  - 若上游调用链增加了读锁，需再次审视是否有隐式 EDT 切换的 API（模态对话框、同步 UI 操作等）。

- **参考链接**
  - IntelliJ 平台进度与协程 API（`runBlockingCancellable`/`withBackgroundProgress`）文档与源码注释
  - 相关变更：`CwtConfigGroupDataProviders.FileBased.kt` 将 `withModalProgress` 替换为 `withBackgroundProgress`